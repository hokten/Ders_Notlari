* Main ToC: Itself excluded
:PROPERTIES:
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#php-i̇le-programlama][PHP İle Programlama]]
  - [[#büyük-küçük-harfe-duyarlılık][Büyük Küçük Harfe Duyarlılık]]
  - [[#boşluk-ve-yeni-satır-karakterleri][Boşluk ve Yeni Satır Karakterleri]]
  - [[#direkt-değişmez-verilerliterals][Direkt Değişmez Veriler(Literals)]]
  - [[#xzxx][xzxx]]
    - [[#expressionsi̇fadeler][Expressions(İfadeler)]]
    - [[#statementsdeyimler][Statements(Deyimler)]]
  - [[#operatörler][Operatörler]]
    - [[#operatörlerin-öncelik-sırası][Operatörlerin Öncelik Sırası]]
- [[#kontrol-yapıları][Kontrol Yapıları]]
  - [[#for-döngüsü][for Döngüsü]]
    - [[#for-döngüsünün-çalışma-şekli][For Döngüsünün Çalışma Şekli]]
  - [[#foreach-döngüsü][foreach Döngüsü]]
  - [[#try-catch-yapısı][try-catch Yapısı]]
  - [[#exit-deyimi][exit Deyimi]]
  - [[#include-deyimi][include Deyimi]]
  - [[#require-deyimi][require Deyimi]]
  - [[#return-deyimi][return Deyimi]]
- [[#fonksiyonlar][Fonksiyonlar]]
  - [[#fonksiyonun-tanımı][Fonksiyonun Tanımı]]
  - [[#fonksiyonların-önemi][Fonksiyonların Önemi]]
  - [[#fonksiyon-türleri][Fonksiyon Türleri]]
    - [[#yerleşikbuilt-in-fonksiyonlar][Yerleşik(Built-In) Fonksiyonlar]]
    - [[#kullanıcı-tanımlı-fonksiyonlar][Kullanıcı Tanımlı Fonksiyonlar]]
  - [[#fonksiyonların-tanımlanması][Fonksiyonların Tanımlanması]]
    - [[#fonksiyon-i̇simlendirme-kuralları][Fonksiyon İsimlendirme Kuralları]]
  - [[#fonksiyonların-çağırılması][Fonksiyonların Çağırılması]]
    - [[#yerleşik-fonksiyon-örnekleri][Yerleşik Fonksiyon Örnekleri]]
      - [[#strlen][strlen]]
      - [[#sin][sin]]
      - [[#substr][substr]]
  - [[#değişken-kapsamı][Değişken Kapsamı]]
  - [[#global-değişkenler][Global Değişkenler]]
  - [[#static-değişkenler][Static Değişkenler]]
  - [[#referans-değişkenler][Referans Değişkenler]]
:END:
* PHP İle Programlama
:PROPERTIES:
:TOC:    :include siblings
:NOTER_DOCUMENT: ../../Calibre Library/Peter MacIntyre/Programming PHP, 4th Edition (14)/Programming PHP, 4th Edition - Peter MacIntyre.pdf
:END:
** Büyük Küçük Harfe Duyarlılık
:PROPERTIES:
:NOTER_PAGE: (62 . 0.7670720299345182)
:TOC:      :depth 0
:END:
Kullanıcılar tarafından tanımlanan sınıf isimleri, yerleşik yapılar ve anahtar kelimeler(~echo~, ~while~, ~class~, ~if~ gibi) büyük-küçük harfe duyarlı değildir.

Örneğin aşağıdaki üç satırın birbirinden farkı yoktur.
#+BEGIN_SRC php
echo("hello, world");
ECHO("hello, world");
EcHo("hello, world");
#+END_SRC

Fakat, değişken isimleri büyük-küçük harfe duyarlıdır. =$Ad$=, =$ad=, =$AD= değişkenleri birbirinden farklıdır ve farklı değerler alabilirler.
** Boşluk ve Yeni Satır Karakterleri
:PROPERTIES:
:NOTER_PAGE: (64 . 0.5893358278765201)
:END:
PHP'de deyimler arasında kullanılan boşluk veya yeni satır karakterleri yorumlayıcı tarafından dikkate alınmaz. 
** Direkt Değişmez Veriler(Literals)
:PROPERTIES:
:NOTER_PAGE: (71 . 0.15715622076707203)
:END:
Programlama dili içerisinde tek başına bir veri taşıma yeteneğine sahip yapılardır. Program içerisinde kullanılan tamsayılar ve kayan noktalı sayılar, tırnak içerisinde yazılan metin ifadeler, =true=, =false=, =null= direkt değişmez verilere örnektirler.
#+BEGIN_EXAMPLE
2001
0xFE
1.343
"Merhaba Dünya"
'Selam'
true
null
#+END_EXAMPLE


** xzxx
:PROPERTIES:
:NOTER_PAGE: 95
:END:
*** Expressions(İfadeler)
Bir ya da daha fazla değişkenden, operatörden (örn. +) veya fonksiyondan meydana gelen ve programlama dili tarafından yorumlandığında bir değer döndüren ifadelerdir.
=4=, =$a+5=, ="Yaz"= ifadelere örnektir.

*** Statements(Deyimler)
Programlama dilinin cümleleridir. Programın en küçük birimleridir. Deyimler ifadelerden oluşur.  PHP'de deyimlerin sonuna noktalı virgül(=;=) karakteri gelir.
** Operatörler
Operatörler, bir veya birden fazla değeri herhangi bir işleme sokan ve yeni bir değer üreten yapılardır. Operatörlerin üzerinde işlem yaptığı değerlere operand denir.
Operatörler aslında fonksiyonların daha kullanışlı halleri olarak düşünülebilir.
Çoğu operatör operandlarının değerini değiştirmemesine rağmen bazı operandlar operandlarının değerlerini değiştirir.
*** Operatörlerin Öncelik Sırası
Birden fazla operatör bir ifade içinde yer aldığında, hangi operatöre ait işlemin önce yapılacağına göre ifadenin değeri değişebilir. Dolayısıyla net değer için hangi operatörün hangisinden önce yapılacağı bilinmelidir. PHP yorumlayıcısı operatörlerden hangisinin diğerinden önce yapılacağını tespit etmek için aşağıdaki operatör öncelik tablosounu kullanır.

| Sıra | Birleşim | Operatör          | Operasyon             |
|   24 | N        | clone, new        | Yeni nesne oluşuturur |
|   23 | L        | [                 | Dizi elemanına erişim |
|   22 | R        | **                | Üst alma              |
|   21 | R        | ~                 | Bitsel Hayır          |
|   21 | R        | ++                | Bir arttırma          |
|   21 | R        | --                | Bir azaltma           |
|   21 | R        | (int), (bool),... | Tür dünüşümü          |
|   21 | R        | @                 | Hataları gizleme      |
|      |          |                   |                       |
* Kontrol Yapıları
** for Döngüsü
#+BEGIN_SRC php
  for(baslangic_ifadesi; dongu_kosulu; adim_sonu_ifadesi)
    tek_deyim;
#+END_SRC

#+BEGIN_SRC php
  for(baslangic_ifadesi; dongu_kosulu; adim_sonu_ifadesi) {
      deyim1;
      deyim2;
  }
#+END_SRC

#+BEGIN_SRC php
  for(baslangic_ifadesi; dongu_kosulu; adim_sonu_ifadesi):
      deyim1;
      deyim2;
  endfor;
#+END_SRC

Döngüler, belirli bir kod bloğunu tekrar tekrar çalıştırmaya yarayan yapılardır. Bu kod bloğuna döngünün *gövdesi* denir. ~for~ döngüsünün gövdesi tek bir deyimden oluşuyorsa, bu gövdeyi küme parantezleri arasına almamız gerekmez.
Fakat gövde birden fazla deyimden oluşuyorsa parantezler arasına yazılmalıdır.
*** For Döngüsünün Çalışma Şekli
1. Program ~for~ döngüsünün başladığı satıra geldiğinde, önce baslangic_ifadesi bölümünü çalıştırır. Bu çalıştırma işlemi koşulsuz ve bir kereye mahsus yapılır.
2. dongu_kosulu mantıksal bir ifade ya da boolean türüne dönüşebilen bir ifade olmak üzere, dongu_kosulu ifadesinin =true= değer döndürüp döndürmediğine bakılır. Eğer =true= değer dönüyorsa, döngünün gövdesi baştan sona çalıştırılır.
3. Gövdenin çalıştırılması işlemi bittikten sonra =adim_sonu_ifadesi= bölümü çalıştırılır. =adim_sonu_ifadesi= her döngü gövdesi çalıştırma işleminden sonra tekrar çalıştırılır.
4.  Program, ~for~ satırına geri döner ve döngü koşulunun =true= değer döndürüp döndürmediğine bakılır. Dönen değer =true= ise 2. ve 3. adım tekrarlanır. =false= ise program, döngü gövdesinin bittiği satırdan sonraki satırdan itibnaren çalışmaya devam eder.
 #+BEGIN_SRC php
   echo "Döngüden önceki satır."
   for ($i = 1; $i <= 3; $i++) {
       echo $i;
       echo "Bitti";
   }
echo "Döngünün bitiş satırı";
 #+END_SRC

 Program 2. satıra geldiğinde, programımız for döngüsünün başlangıç ifadesi adı verilen ve ilk noktalı virgüle kadar olan ifadeyi hiçbir koşul gözetmeksizin çalıştıracaktır. O halde, 2. satıra gelindiğinde $i=1 olacaktır.

Yine 2. satırda, bu işlemini hemen sonrasında döngünün çalışıp çalışmayacağını anlamak için, birinci ; ile ikinci ; arasında kalan ifadenin sonucuna bakılır. Eğer bu sonuç true ise döngünün kod bloğu çalıştırılmaya başlanır ve program 3.satırdan(döngünün kod bloğunun başı) 4. satıra(döngünün kod bloğunun sonu) kadar çalıştırılır.

satır çalıştıktan sonra döngünün kod bloğu baştan sona çalıştırılmış olur. Program tekrar for satırına geri dönüp for deyiminin ikinci ; karakterinden sonra gelen bitiş ifadesi çalıştırır.

Sonrasında tekrar koşul ifadesine bakılır. Eğer koşul ifadesi doğru ise aynı işlemler tekrarlanır. Eğer koşu ifadesi false ise döngünün kod bloğunun bittiği yerden(6. satır) program devam eder.

#+BEGIN_SRC php
echo "Döngüden önceki satır.\n";
for ($i = 1; $i <= 3; $i++) {
    echo "Adım $i\n";

}
echo "Döngüden sonraki satır.\n";
#+END_SRC


#+BEGIN_SRC php
  $yazi = "MerhabaDünya";
  $bas=8;
  $son=10;
  for($i=$bas; $i<=$son; $i++) {
      echo $yazi[$i];
  }
#+END_SRC

#+RESULTS:
: ün

** foreach Döngüsü
Dizi türünden değişkenlerin yada değerlerin elemanlarını taramak için kullanılır. Bu döngünün 
her bir adımında, dizinin önceki adımda erişilen elemanını takip eden elemanına döngü kod bloğu 
içerisinde bir değişken vasıtasıyla erişebiliriz.

Çoğu dizinin elemanlarına for döngüsü yardımıyla erişilebilir. Aşağıdaki örneği inceleyelim.
#+BEGIN_SRC php
$dizi=[3,9,2,5];
for($i=0; $i<count($dizi); $i++) {
    echo $dizi[$i];
    echo "\n";
}
#+END_SRC

#+RESULTS:
: 3
: 9
: 2
: 5
Anahatar-Değer formunda verilen dizileri for döngüsü baştan sona taramak bazen güç olabilir. Aşağıdaki örneği inceleyelim.
#+BEGIN_SRC php
  $ogrenciler=[
      1234 => "Ali Veli",
      2345 => "Fatma ŞAHİN",
      3564 => "Seyfi DOĞAN"];

  for($i=0; $i<=3564; $i++) {
      if(isset($ogrenciler[$i])) {
          echo $ogrenciler[$i];
          echo "\n";
      }
  }
#+END_SRC

#+RESULTS:
: Ali Veli
: Fatma ŞAHİN
: Seyfi DOĞAN

Aynı örneği foreach döngüsü ile yapalım.
#+BEGIN_SRC php
  $ogrenciler=[
      1234 => "Ali Veli",
      2345 => "Fatma ŞAHİN",
      3564 => "Seyfi DOĞAN"];

  foreach($ogrenciler as $ogrenci) {
          echo $ogrenci;
          echo "\n";
  }
#+END_SRC

#+RESULTS:
: Ali Veli
: Fatma ŞAHİN
: Seyfi DOĞAN


  #+BEGIN_SRC php
  $dizi=[3,9,2,5];
  for($i=0; $i<count($dizi); $i++) {
      echo $dizi[$i];
      echo "\n";
  }

  foreach($dizi as $eleman) {
      echo "$eleman\n";
  }
#+END_SRC

foreach döngüsünde, istenildiği takdirde dizi anahtarlarına da ulaşılabilir. 
#+BEGIN_SRC php
$ogrenciler=[
    123 => "Ali Veli",
    125 => "Fatma Şahin",
    345 => "Suat AK"
    ];

foreach($ogrenciler as $numara => $adsoyad) {
    echo "$adsoyad isimli öğrencinin numarası $numara\n";
}
#+END_SRC

#+RESULTS:
: Ali Veli isimli öğrencinin numarası 123
: Fatma Şahin isimli öğrencinin numarası 125
: Suat AK isimli öğrencinin numarası 345
** try-catch Yapısı
try-catch, hata ve istisna tespiti için kullanılan bir yapıdır. try-catch yapısı,
#+BEGIN_SRC php
    try {
      // Hata yada istisna üretebilecek kod
    }
    catch (Exception $error) {
      // Hata durumunda yapılacaklar
    }
#+END_SRC

#+BEGIN_SRC php
  try {
      $dbhandle = new PDO('mysql:host=localhost; dbname=library', $username, $pwd);
      doDB_Work($dbhandle); 
      $dbhandle = null; 
  }
  catch (PDOException $error) {
      print "Error!: " . $error->getMessage() . "<br/>";
      die("Hata");
  }
echo "devam";
#+END_SRC

Program try bloğu içerisindeki kodları çalıştırmayı dener. Eğer bu çalıştırma işlemi sorunsuz olarak gerçekleşirse, program direkt olarak ~echo "devam"~ satırına atlar ve çalışmaya devam eder. Fakat, try bloğu içerisinde bir sorunla karşılaşılırsa catch bloğu işletilir. catch bloğu, parametre olarak Exception nesnesi alır ve bu nesne try bloğunda oluşan sorunu tanımlayabilmek için bize yardımcı olur.
** exit Deyimi
~exit~ deyimi, programın çalışmasını sonlandırır. 
~exit~ deyimi, ~exit 3~ şeklinde parametre alır. Bu parametre, programın doğru çalışıp çalışmadığı hakkında bize bilgi verir.
Örneğin, ~exit(0)~ veya ~exit 0~ ile programı sonlandırmak, programın başarılı bir şekilde çalıştığı anlamına gelir.
~exit~ fonksiyonuna string türünde parametre verildiğinde, program bu parametreyi yazdırarak çalışmasını durdurur.
~exit~ fonksiyonun diğer bir takma ismi ~die~ fonksiyonudur. Bu iki fonksiyon birbiri yerine kullanılabilir.

#+BEGIN_SRC php
  for($i=1; $i<=40; $i++) {
      if($i==35) {
          return;
      }
      echo "$i\n";
  }
  echo "Bitti";
#+END_SRC

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
#+end_example
** include Deyimi
Harici dosyalar ~include~ deyimi ile herhangi bir dosyaya eklenebilir. Bu eklenen kodlar, eklendiği yerde çalıştırılır. Dolayısıyla eklenenen bu dosyadaki değişkenleri ve fonksiyonları eklediğimiz dosya içerisinde kullanabiliriz.
~include~ deyimi aşağıdaki şekilde kullanılır.

#+BEGIN_SRC  php
  include "klasor1/dosya1.php";
  include "dosya.php";
  include("ekle.php");
  include("abc.html");
  include "http://www.abc.com/xyz.php"
#+END_SRC

~include~ deyiminden sonra gelen ve koda eklenecek olan dosyayı gösteren parametre, bir dosya yolu olmak zorundadır. Bu dosya yolu, PHP'nin ayarlarında yer alan, ~include_path~ klasörü içinde aranır. İlgili dosya, ~include_path~ ayarında belirtilen klasörlerde bulanamazsa, ~include~ deyiminin kullanıldığı PHP dosyasının bulunduğu klasöre bakılır. Eğer, ilgili dosya belirtilen konumlarda bulunamazsa, PHP bu dosyanın bulunamadığına dair bir uyarı(Warning) mesajı verecektir. Fakat, ana kod programımızın çalışması kesintiye uğramayacak ve programımız ~include~ deyiminden sonraki satırdan çalışmaya devam edecektir.

#+BEGIN_VERSE
PHP'den, *Warning* tipinde bir bildirim aldığımızda, programın çalışması kesintiye uğramadan devam edecektir.
#+END_VERSE

Mesela, PHP ayarlarında, ~include_path=/home/php/~ olsun.
Ben, ~/var/www/localhost/htdocs/~ klasörü içerisindeki ~deneme.php~ dosyasını düzenliyor olayım.

deneme.php
#+BEGIN_SRC php
include "abc.php"
 #+END_SRC

** require Deyimi
~require~ deyimi, ~include~ deyimi ile aynı işleve sahiptir. Kullanım şekli ve amacı ~include~ ile aynıdır. İkisi arasındaki tek fark, ~require~ deyimi, ~require~ ile eklenecek olan dosyayı bulamaması durumunda, bir *Fatal Error* üretecektir. PHP, *Fatal Error* bildirimi aldığında, programın çalışmasına o noktada son verecektir. Dolayısıyla, var olmayan bir dosyayı ~include~ ile programımıza dahil ettiğimizde, bir *Warning* bildirimi alırız ve programımız çalışmaya devam eder. Aynı şekilde, var olmayan bir dosyayı ~require~ ile programımıza dahil ettiğimizde bir *Fatal Error* bildirimi alırız ve program o noktada sonlanır, çalışmaya devam etmez.

** return Deyimi
~return~ deyiminin fonksiyonlar içinde kullanımını fonksiyonlar konusunda işleyeceğiz. ~return~ deyimi ana program kodu içerisinde kullanıldığında programı sonlandırır. Bu bağlamda düşünüldüğünde ~exit~ ile aynı işleve sahip olacaktır. 

#+NAME: ~return~ deyiminin fonksiyon gövdesi dışında kullanılması.
#+BEGIN_SRC php :exports both
  $deneme="abc";
  if($deneme=="abc") {
      for($i=0; $i<=5; $i++) {
          if($i==3) {
              return;
          }
          echo $i."- Döngü içi\n";
      }
      echo "Döngü dışı";
  }
  echo "İf dışı";
#+END_SRC

#+RESULTS: ~return~ deyiminin fonksiyon gövdesi dışında kullanılması.
: 0- Döngü içi
: 1- Döngü içi
: 2- Döngü içi

Yukarıdaki programda görüldüğü gibi, ~return~ deyimi ~break~ deyiminden farklı olarak bir bloğun çalışmasını değil tüm programın çalışmasını sonlandırır.

~return~ anahtar kelimesi, ~include~ ve ~require~ içinde de kullanılabilir. ~include~ deyiminin parametresi olan dosyaya *dahil edilen dosya*, ~include~ deyiminin kullanıldığı dosyaya da *ana kod dosyası* şeklinde tanımlayalım. ~return~ deyimi dahil edilen dosya içerisinde direkt kullanıldıysa (yani bir fonksiyon gövdesinde kullanılmadıysa), kullanıldığı satırda dahil edilen dosyanın çalışmasını sonlandırır. Program, ana kod dosyasının, ilgili ~include~ deyiminden sonraki satırdan itibaren çalışmaya devam edecektir. Diğer bir deyişle, ~return~ deyiminin kullanıldığı satırdan itibaren programın çalışmasını sırasını ana kod dosyasına devreder.
Aynı durumlar ~require~ içinde geçerlidir.

* Fonksiyonlar
** Fonksiyonun Tanımı
Tekrar etmesi muhtemel belirli bir görevi yerine getiren kod bloğunun isim verilmiş haline *fonksiyon* denir.
Program içerisinde, isim verilen bu kod bloğunun görevi gerektiğinde, sadece ismi ile çağırılıp çalıştırılabilir.

İsim verilen bu kod bloğu(fonksiyon), ayrıca icra edeceği görevi özelleştirebilmek için *parametre* adı verilen değer veya değerleri kullanılabilir.

Ayrıca, icra edilen görev tamamlandığında, görevin bir çözümü olarak değer veya değerler döndürebilir. Bu değere *fonksiyonun dönen değeri* denir ve bu şekildeki fonksiyonlara *değer döndüren fonksiyonlar* denir.

Fonksiyonlar, matematiksel fonksiyonlar gibidir. Örneğin ~f(x)=x*x+2~ fonksiyonunu düşünürsek, burada ~x~ fonksiyonun bir parametresidir ve fonksiyon bir parametrelidir. ~x*x+2~ fonksiyonun hem icra ettiği görev hem de dönen değeridir. Örneğin ~x=3~ alınırsa, fonksiyonun dönen değeri ~11~ olur.
** Fonksiyonların Önemi
Aynı işlevi gören kod bloğu, işlevin gerektiği her yerde bir bütün olarak kullanılması gerekecekti. Kod bloğunuzda bir hata tespit ettiğinizde veya bir geliştirme yapmak istediğinizde, programınızın çeşitli yerlerine eklemiş olduğunuz bu kod bloklarını bulup gerekli düzeltmeleri veya iyileştirmeleri her biri için teker teker yapmanız gerekecek.
Bu kod bloğu fonksiyon olarak tanımlanmış olsaydı, sadece fonksiyonun tanımlandığı kod bloğunda yapılan değişiklikler fonksiyonun çağırıldığı her noktaya etki eder. 
** Fonksiyon Türleri
*** Yerleşik(Built-In) Fonksiyonlar
Tüm programcılar tarafından kullanılması muhtemel bazı görevler(çıktı yazdırma, karekök alma gibi), dili oluşturanlar tarafından yerleşik olarak fonksiyon haline getirilmiştir. Herhangi bir tanımlama yapılmadan, programcı bu fonksiyonları kullanabilir. Örneğin, ~echo~, ~var_dump~, ~sqrt~ yerleşik fonksiyonlardır.
*** Kullanıcı Tanımlı Fonksiyonlar
Programcı tarafından tanımlanan fonksiyonlardır. 
** Fonksiyonların Tanımlanması
Bir PHP fonksiyonu,

#+BEGIN_SRC php
  function fonksiyon_ismi(parametre1, parametre2, ...) {
      deyim_veya_deyimler;
  }
#+END_SRC

Fonksiyon isminden sonra gelen parantezler arasına yazılan ve virgüllerle birbirinden ayrılan yapılar fonksiyonun parametreleridir. Fonksiyonun sıfır veya daha fazla parametresi olabilir.

Deyim bölümünde HTML kodları da kullanılabilir. Hatta hiç PHP kodu içermeyen Fonksiyonlarda oluşturulabilir. Örneğin,
#+BEGIN_SRC php
  <?php
  function sutun()
  { ?>
      </td></td>
  <?php } ?>
#+END_SRC

Yukarıdaki ~sutun~ fonksiyonunun hiç parametresi yoktur.
Fonksiyonlar çoğu zaman değer döndürürler. Fonksiyonun kod bloğunda değer döndürme eylemi ~return~ deyimi ile gerçekleştirilir. ~return~ deyimi, ~return ifade~ veya ~return $degisken~ şeklinde kullanılır. Fonksiyon çalışırken ~return~ deyimi ile karşılaşırsa, fonksiyonun çalışması sonlanır ve ~return~ ile dönen değer fonksiyonun çağırıldığı deyime aktarılır. Bir fonksiyon içerisinde birden fazla ~return~ deyimi kullanılabilir.

  #+BEGIN_SRC php
    function birlestir($sol, $sag) {
        $bilesik = $sol . $sag;
        return $bilesik;
    }
  #+END_SRC


Yukarıdaki fonksiyon, ~$sol~ ve ~$sag~ adlı iki parametre alır ve bunların birleşmesi ile elde ettiği metni döndürür. ~return~ deyiminden sonra ifadelerde kullanılabileceği için aynı fonksiyon daha sade,

  #+BEGIN_SRC php
    function birlestir($sol, $sag) {
        return $sol . $sag;
    }
  #+END_SRC

şeklinde tanımlanabilir.
Tanımlanan fonksiyonlar, programın herhangi bir yerinde kullanılabilir.

#+BEGIN_SRC php
  echo birlestir("Hasan", "ÖKTEN");

  function birlestir($sol, $sag) {
      return $sol . $sag;
  }
  #+END_SRC

  #+RESULTS:
  : HasanÖKTEN

*** Fonksiyon İsimlendirme Kuralları
- Fonksiyon isimleri, harf, alt tire, rakam sembollerinin bir veya daha fazla kombinasyonundan oluşmalıdırlar. 
- Fonksiyon isimleri harf veya _ ile başlamalıdır.
- Fonksiyonları isimleri büyük-küçük harflere duyarlı değildir.

  #+BEGIN_EXAMPLE
  #+BEGIN_SRC php
  8tas() // Yanlış fonksiyon ismi. (Rakam ile başlamış)
  -aktif(5) // Yanlış fonksiyon ismi. (- ile başlamış)
  bas harfi al("Ali") // Yanlış fonksiyon ismi. (Boşluk içeriyor)
  buyut("ali") // Doğru fonksiyon ismi.
  _aktifet($pasif) // Doğru fonksiyon ismi.
  altiniciz("metin"); // Yandaki üç
  AltiniCiz("metin"); // fonksiyonda aslında
  ALTINICIZ("metin"); // aynı fonksiyondur. Aynı işleve sahiptirler.
  #+END_SRC
  #+END_EXAMPLE
  
** Fonksiyonların Çağırılması
Tanımlanmış fonksiyonlar, programın herhangi bir yerinde isimleri ile çağırılabilirler. Ayrıca, fonksiyon isminden sonra varsa, iki parantez arasına parametreleri yazılır.
~echo("Yaz")~, ~kareal(3)~, ~tabloyap()~

Fonksiyonlara verilen parametreler, fonksiyonun tanımının gerektirdiği sayıda ve sırada olmalıdır.
#+BEGIN_SRC php
  function cikar(eksilen, cikan) {
      return eksilen-cikan;
  }
#+END_SRC
Örneğin yukarıda tanımlanan ~cikar~ fonksiyonu, ~eksilen~ ve ~cikan~ isimlerine sahip iki parametre almaktadır. Bu durumda, ~cikar~ fonksiyonu, ~cikar(5)~ veya ~cikan(1,2,3)~ şeklinde çağırılmaya çalışıldığında hata oluşur. Çünkü ~cikar~ fonksiyonu tanımı gereği tam olarak iki parametre almak zorundadır.
Benzer şekilde, 10 sayısından 7 sayısını çıkarmak için ~cikar~ fonksiyonunu kullandığımızı düşünelim. Eğer fonksiyonu, ~cikar(7,10)~ şeklinde kullanırsak, program hata üretmemesine rağmen, parametreleri yanlış sırada kullandığımız için hesaplama hatası ile karşı karşıya kalırız.

*** Yerleşik Fonksiyon Örnekleri
**** strlen
Metin türünden bir değerin toplam karakter sayısını döndürür. ~strlen~ fonksiyonun icra ettiği görev düşünüldüğünde, parametre sayısının bir olduğu ve tamsayı türünden bir değer döndürdüğü kolaylıkla anlaşılabilir.
**** sin
~sin~ fonksiyonun dökümantasyonuna incelendiğinde, =sin(float $num) : float= biçiminde tanımlandığı görülebilir.
=float $num=, ~sin~ fonksiyonunun =$num= isimli bir parametre alacağını ve bu parametrenin =float= türünden olacağını belirtmektedir. Ayrıca, ~sin~ fonksiyonu sadece bir tane parametre alır ve bu parametrede =$num= parametresidir.
=:= karakterinden sonra gelen sözcük ise, fonksiyonunun döndürdüğü değişken türünü göstermektedir. O halde =sin= fonksiyonu =float= türünden bir değer döndürmektedir.
**** substr
~substr~ fonksiyonu, =substr(string $dizge, int $başlangıç [,int $uzunluk]) : string= şeklinde tanımlanmıştır. Fonksiyon tanımlamalarında, =[]= arasında verilen parametreler *opsiyonel* yani seçimliktir. Bu parametreler fonksiyona verilmese de fonksiyon çalışır. O halde =substr= fonksiyonu, iki zorunlu ve bir seçimlik parametreye sahiptir. Zorunlu parametreler =$dizge= ve =$başlangıç= parametreleridir. =$dizge= kesit alacağınız metni temsil eder ve =$başlangıç= ise kesit alma işleminin hangi sıradaki karakterden başlanarak yapılacağını belirtir.
Eğer =$uzunluk= parametresi kullanılmazsa, kesit alma işlemi belirtilen sıradan metnin son karakterine kadar yapılır. =$uzunluk= parametresi kullanılırsa, kesit alma işlemi belirtilen sıradaki karakter =$uzunluk= kadar ilerlenerek yapılır.

#+BEGIN_SRC php
  $metin="Merhaba";
  echo substr($metin, 2); // $uzunluk parametresi olmadığından metnin sonuna kadar ilerledi.
  echo "\n";
  echo substr($metin, 3, 3) 
#+END_SRC

#+RESULTS:
: rhaba
: hab

** Değişken Kapsamı
Eğer programınızda hiçbir fonksiyon kullanmıyorsanız, bir değişkeni oluşturduktan satırdan sonra herhangi bir yerde bu değişkeni kullanabilirsiniz.
Fakat fonksiyonlar içinde tanımlananan değişkenler, özel teknikler kullanılmadıysa sadece fonksiyon içinde geçerli olurlar.
Benzer şekilde genel olarak, programın ana kod parçasında veya bir başka fonksiyonda tanımlanan değişkenler, diğer fonksiyon içerisinde kullanılamazlar.
Bir değişkenin geçerli olduğu(kullanılabildiği) kod parçasına, o değişkenin *kapsamı* denir.

#+CAPTION: HelloWorldCaption
#+srcname: HelloWorldSrcName
#+BEGIN_SRC php
  $a = 3;

  function foo()
  {
      $a += 2;
      $b=5;
  }
  foo();
  echo $b;
  echo $a;
#+END_SRC

#+RESULTS:
: 3

Yukarıdaki programın çıktısı 3 olacaktır. Baştaki ~$a~ değişkeni ana program bloğunda tanımlanmıştır. ~foo~ fonksiyonu içinde ~$a~ değişkeninin değerini kullanmak mümkündür fakat bu ancak ~$a~ değişkenin ~foo~ fonksiyonuna parametre olarak verilmesiyle olur. Bu durumda bile aslında ~foo~ fonksiyonuna ~$a~ değişkeninin kendisini değil o anki değerinin bir kopyasını gönderöiş oluyoruz. Benzer şekilde, ~foo~ fonksiyonun içindeki ~$a~ değişkeni de ana kod bloğunda kullanılamaz. Ana kod parçasındaki ~$a~ değişkeni ile ~foo~ fonksiyonu iççindeki ~$a~ değişkeninin birbirleriyle hiçbir ilgisi yoktur. Bunlar kapsamları farklı olan iki farklı değişkendirler.
Fonksiyon içinde tanımlanan değişkenlerin kapsamları en fazla fonksiyonun kod bloğu kadar olur. Bu kapsama *fonksiyon seviyesi kapsam* denir. Örneğin ~foo~ fonksiyonu içinde tanımlanan ~$a~ değişkenini ömrü fonksiyon kod bloğunun kapama parantezine kadardır.
Fonksiyonların ve sınıfların dışında tanımlanan değişkenlerin kapsamına *global seviye kapsam* denir.
*Super global seviye kapsama* sahip değişkenler ise her iki kapsam içinde kullanılabilirler.

** Global Değişkenler
Global kapsamda yer alan bir değişkeni bir fonksiyon içinde kullanmak için ~global~ anahtar deyimi kullanılır. Bir önceki örneği bu şekilde düzenlersek, ana kod parçasında ve ~foo~ fonksiyonu içinde kullandığımız ~$a~ değişkenleri artık aynı değişken olacaktır. 

#+BEGIN_SRC php
  $a = 3;
  function foo()
  {
      global $a;
      $a += 2;
  }
  foo();
  echo $a;
#+END_SRC

#+RESULTS:
: 5

** Static Değişkenler
Normalde, bir fonksiyon her çağırıldığında fonksiyonun içindeki değişkenler tekrardan tanımlanır. Yani, değerlerini saklamazlar. Aşağıdaki örneği inceleyelim.
#+BEGIN_SRC php
  function deneme()
  {
      $b +=3; // $b=$b+3; $b=0+3 = 3; 
      return $b;
  }
  echo deneme();
  echo "\n";
  echo deneme();
#+END_SRC

#+RESULTS:
: 3
: 3

Örnekte görüldüğü gibi, =$b= değişkeninin kapsamı =deneme= fonksiyonunu gövdesi olduğundan dolayı, değişken her fonksiyon çağırılışında tekrardan oluşturuluyor. =deneme= fonksiyonu ilk defa çağırıldığında =$b= en son olarak =3= değerini aldı ve fonksiyon görevini bitirdiğinde =$b= değişkeni bellekten silindi.  =deneme= fonksiyonu tekrar çağırıldığında, =$b= değişkeni yeniden oluşturuldu ve varsayılan olarak =0= değerini aldı.
Bir değişkeni; fonksiyonun her çağırılışında, bu değişkenin fonksiyonun önceki çağırılışlarında aldığı değerleri kaybetmeden kullanmak istiyorsak ~static~ anahtar kelimesini kullanmalıyız. Aşağıdaki örnekte bir fonksiyonun kaç defa çağırıldığını statik değişkenler yardımıyla bulacağız.
#+BEGIN_SRC php :exports both
  function deneme()
  {
      static $cagirilma_sayisi=0;
      $cagirilma_sayisi++;
      echo "deneme() fonksiyonunu {$cagirilma_sayisi}. çağırışınız.\n";
  }
  deneme();
  deneme();
  deneme();
#+END_SRC

#+RESULTS:
: deneme() fonksiyonunu 1. çağırışınız.
: deneme() fonksiyonunu 2. çağırışınız.
: deneme() fonksiyonunu 3. çağırışınız.

** Referans Değişkenler
Bir fonksiyona, değişkenin değerini değil, değişkenin bulunduğu bellek adresini kullanarak parametre olarak verebiliriz. Bu durumda, fonksiyon içinde bu referans değişkeni uygulanan tüm işlemler, değişkeni de doğrudan etkileyecektir.

#+BEGIN_SRC php

$sayi=15;
  function deneme(&$giren)
  {
      $b +=3; // $b=$b+3; $b=0+3 = 3; 
      return $b;
  }
  echo deneme();
  echo "\n";
  echo deneme();
#+END_SRC
xxkkdd

ddd

