* İnternet Programcılığı - I Ders Notları
** İçindekiler
:PROPERTIES:
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#i̇nternet-programcılığı---i-ders-notları][İnternet Programcılığı - I Ders Notları]]
  - [[#php-dilinin-temelleri][PHP Dilinin Temelleri]]
    - [[#büyük-küçük-harfe-duyarlılık][Büyük Küçük Harfe Duyarlılık]]
    - [[#boşluk-ve-yeni-satır-karakterleri][Boşluk ve Yeni Satır Karakterleri]]
    - [[#direkt-değişmez-verilerliterals][Direkt Değişmez Veriler(Literals)]]
    - [[#xzxx][xzxx]]
      - [[#expressionsi̇fadeler][Expressions(İfadeler)]]
      - [[#statementsdeyimler][Statements(Deyimler)]]
    - [[#operatörler][Operatörler]]
      - [[#operatörlerin-öncelik-sırası][Operatörlerin Öncelik Sırası]]
  - [[#kontrol-yapıları][Kontrol Yapıları]]
    - [[#for-döngüsü][for Döngüsü]]
      - [[#for-döngüsünün-çalışma-şekli][For Döngüsünün Çalışma Şekli]]
    - [[#foreach-döngüsü][foreach Döngüsü]]
    - [[#try-catch-yapısı][try-catch Yapısı]]
    - [[#exit-deyimi][exit Deyimi]]
    - [[#include-deyimi][include Deyimi]]
    - [[#require-deyimi][require Deyimi]]
    - [[#return-deyimi][return Deyimi]]
  - [[#fonksiyonlar][Fonksiyonlar]]
    - [[#fonksiyonun-tanımı][Fonksiyonun Tanımı]]
    - [[#fonksiyonların-önemi][Fonksiyonların Önemi]]
    - [[#fonksiyon-türleri][Fonksiyon Türleri]]
      - [[#yerleşikbuilt-in-fonksiyonlar][Yerleşik(Built-In) Fonksiyonlar]]
      - [[#kullanıcı-tanımlı-fonksiyonlar][Kullanıcı Tanımlı Fonksiyonlar]]
    - [[#fonksiyonların-tanımlanması][Fonksiyonların Tanımlanması]]
      - [[#fonksiyon-i̇simlendirme-kuralları][Fonksiyon İsimlendirme Kuralları]]
    - [[#fonksiyonların-çağırılması][Fonksiyonların Çağırılması]]
      - [[#yerleşik-fonksiyon-örnekleri][Yerleşik Fonksiyon Örnekleri]]
        - [[#strlen][strlen]]
        - [[#sin][sin]]
        - [[#substr][substr]]
    - [[#değişken-kapsamı][Değişken Kapsamı]]
    - [[#global-değişkenler][Global Değişkenler]]
    - [[#static-değişkenler][Static Değişkenler]]
    - [[#referans-değişkenler][Referans Değişkenler]]
    - [[#varsayılan-parametreler][Varsayılan Parametreler]]
    - [[#parametre-fonksiyonları][Parametre Fonksiyonları]]
    - [[#parametre-türünü-belirtmetype-hinting][Parametre Türünü Belirtme(Type Hinting)]]
    - [[#fonksiyondan-birden-fazla-değer-döndürme][Fonksiyondan Birden Fazla Değer Döndürme]]
    - [[#fonksiyonun-dönüş-değerini-bildirme][Fonksiyonun Dönüş Değerini Bildirme]]
      - [[#i̇simsiz-fonksiyonlar][İsimsiz Fonksiyonlar]]
:END:

** Webin Temelleri
*** HTTP ve HTML
HTTP, kullanıcıların bilgisayarındaki web tarayıcısı ile web sayfalarını barındıran web sunucuları arasındaki iletişimin biçimini, işleyişini kurallara bağlayan bir iletişim standardıdır.
Web sunucusunun görevi, sunmakla yükümlü olduğu web sayfalarına gelen istekleri beklemek ve eğer istekler geçerli ise ilgili web sayfasını istemci bilgisayara göndermektir.
Web sunucu ile istemci çoğu zaman direkt iletişim kurmazlar.İstek ve cevapların doğru şekilde aktarılmasını sağlamak için istemci ile sunucu arasında router, gateway, proxy gibi cihazlar yer alabilir.
Bu cihazlar, istemcinin aynı bilgiyi tekrar istemesi gibi durumlarda veri trafiğini azaltmak ve web sitesinin yüklenme hızını arttırmak için web sayfalarını veya bilgileri /önbellekleyebilir/.
İstemci tarafından istenilen veri eğer ara cihazlarda önbelleğe alındıysa, cevap sunucudan değil aradaki cihazdan yapılır. Böylelikle verinin istemciye ulaşması için dolaşacağı yol azaltılmış ve verinin yüklenme hızı arttırılmış olur.
Web sunucuları aynı anda bir çok isteğe cevap verebilecek şekilde dizayn edilmişlerdir. Sunucu herhangi bir isteğe cevap vermediği anlarda dinleme eylemeni gerçekleştirir. Yani, gelebilecek isteklere cevap verebilmek için tetikte bekler.

İstemci ile *statik* bir web sunucu arasındaki iletişim genellikle aşağıdaki sırada gerçekleşir.

1. İstemci web tarayıcısından bir bağlantıya tıklayarak ve adresi bağlantı çubuğuna yazarak http://www.sunucu.com adresine girer.
2. Tarayıcı www.sunucu.com alan ismine karşılık gelen IP adresini tespit eder.
3. Tarayıcı öğrendiği IP adresine ait web sunucuya web sitesinin ana sayfasını görüntülemek üzere istekte bulunur.
4. Bu istek internet ağı vasıtasıyla web sunucuya ulaşır.
5. Web sunucu isteği alır ve bu istek doğrultusunda web sitesinin ana sayfasını diskinde arar.
6. Web sunucusu ilgili sayfayı bulur ve iletişim halinde olduğu istemciye yollar.
7. İstemcinin bilgisayarındaki tarayıcı ilgili sayfayı görüntüler.

Aslında web sayfası içinde düz metinden farklı her bileşen(resim dosyalar, videolar) için aynı işlemler tekrarlanır.
  
Bir web sitesine erişmek için tarayıcıya web sitesinin adresini yazarız veya bağlantılara tıklarız. Web sitelerinin adresleri bilindiği üzere www.sunucu.com biçimindedir ve bunlara *alan adı* denir. Alan adları ziyaretçilerin web sitelerine daha kolay ve akılda kalıcı şekilde erişebilmelerine yarar. Aslında bilindiği gibi internet üzerinde her türlü iletişim IP adresleri vasıtasıyla olur. Dolayısıyla istemci ile web sunucu arasındaki iletişim için de hem istemcinin hem de sunucunun IP adresleri gereklidir. İstemcinin web sunucusuna yollamak için hazırladığı istek paketinin içinde kendi IP adresi de vardır. İlk aşamada istemcinin web sunucu hakkındaki tek bilgisi web sunucunun alan adıdır. Tabii ki istemcinin web sunucu ile iletişim kurabilmesi için web sunucunun IP adresine ihtiyacı vardır. Bu aşamada devreye *alan adı sunucuları* girer. Alan adı sunucuları sayesinde bir alan adına karşılık gelen IP adresini öğrenebiliriz. 2. adımda tarayıcı, www.sunucu.com alan adına sahip sunucunun IP adresini öğrenebilmek için alan adı sunucularına bir sorgu gönderir. Alan adı sunucularının bu sorguya cevabı ise www.sunucu.com alan adına karşılık gelen IP adresidir.

Yukarıda istemci ile statik web sayfaları barındıran bir web sunucunun iletişim adımlarını inceledik.
Eğer web sayfalarımızın *dinamik* olmasını istiyorsak bu iletişim adımları biraz değişecektir. Öncelikle *dinamik web sayfalarının* ne anlama geldiğinden bahsedelim. Dinamik web sayfaları, kullanıcıların farklı isteklerine farklı cevaplar verme beceresine sahip olan web sayfalarıdır. Örneğin saati gösteren bir web sayfası dinamik olmak zorundadır. Çünkü örneğin kullanıcı sayfaya 10:05 itibariyle girdi ise 10:05, 13:50 itibariyle girdi ise 13:50 yazmalıdır. Yani aynı sayfa kullanıcının girdiği saate göre farklı metinler içermelidir. Bu tamda dinamik web sayfalarının davranma biçimidir.
Dinamik web sayfaları oluşturmak için PHP ve MySql kullanılabilir. PHP

#+NAME: fig:figure name
#+CAPTION: figure name
#+ATTR_ORG: :width 600
[[file:/home/okten/Downloads/2021-09-29-Note-12-25.png]]

*** MariaDB: MySQL Klonu
Oracle, MySQL'i geliştiren şirket olan Sun MicroSystems'i satın aldıktan sonra, MySQL'e katkı sağlayan geliştirici topluluğu projenin gelecekte  açık kaynak kodlu olarak kalıp kalmayacağı konusunda endişeler duymaya başladılar. 
** PHP Dilinin Temelleri
:PROPERTIES:
:TOC:    :include siblings
:NOTER_DOCUMENT: ../../Calibre Library/Peter MacIntyre/Programming PHP, 4th Edition (14)/Programming PHP, 4th Edition - Peter MacIntyre.pdf
:END:
*** Literals(Veri Sabitleri)
Sabit verileri ifade etmek için kullanılan yapılara literal denir.
134
-45
21
0xA3
4.56
-3.245
2.00
"Merhaba"
""
" "
'g'
true
false
null
*** Identifiers(Tanımlayıcılar)
Değişkenlere, fonsksiyonlara, sınfılara kodlayan kişi tarafından verilen isimlere denir.
- Tanımlayıcılar, a-z  A-Z _ ve 0-9 içerirler.
- Tanımlayıcılar Türkç karakterler ve boşluk içermezler.
- Tanımlayıcıların ilk karakteri rakam olamaz.
  YaNlış Tanımlayıcılar
  3tas
  buyuk sayi
  küçüksayı
  en-buyuk
  en?buyuk

  Dogru Tanımlayıcılar
  uctas
  tas8
  t2tr
  en_buyuk_sayi
  _enbuyuk
**** Değişken İsimleri
Değişken isimleri, $ karakteri ve onu takip eden bir tanımlayıcıdan oluşur.
$en_buyuk_sayi
$sayi7

$ sayidogrusu    //$ karakterinden sonra geçerli bir tanımlayıcı gelmiyor.
$9tas // 9tas geçerli bir tanımlayıcı değil. Çünkü rakam ile başlıyor.
$_en_son

Değişken isimleri büyük-küçük harf ayrımı yapar. Yani $buYUK degiskeni ile $buyuk değişkeni aynı değişkenler değillerdir.
**** Fonksiyon İsimleri
Fonksiyon isimleri direkt tanımlayıcı olarak seçilirler. Fonksiyon isimleri büyük-küçük harf ayrımı yapmaz.
echo
EcHo
karesini_al
3tas   // Geçerli bir tanımlayıcı değil
**** Sınıf İsimleri
Sınıf isimleri de geçerli bir tanımlayıcı olmalıdır. Büyük-küçük harf ayrımı yapmaz.
**** Sabitler
Sabit isimleri geçerli bir tanımlayıcı olmalıdır. Adet olarak, sabit isimleri büyük harflerle ifade edilir.
sabitler =define= yapısı ile tanımlanır.

~define('PI', 3.14)~
Yukarıdaki ifade =3.14= değerine sahip PI isimli  bir sabit oluşturur. 
*** Veri Türleri
**** Skaler Veri Türleri
- Integer (Tamsayılar)
- Floating-Point(reel Sayılar)
- String(Metin)
- Boolean(true, false)
**** Birleşik Veri Türleri
- Array(Dizi)
- Object(Nesne)
**** Özel Veri Türleri
- Resource
- Null

**** Integer Veri Türü
Tamsayı veri türüdür. Platformdan platforma değişmekle beraber -2,147,483,648 ile -2,147,483,647 arasında değerler alabilir.

#+BEGIN_SRC php
  echo PHP_INT_MIN;
  echo "\n";
  echo PHP_INT_MAX;
  $sayi = 1239223372036854775807;
  echo "\n";
  echo $sayi;
#+END_SRC

#+RESULTS:
: -9223372036854775808
: 9223372036854775807
: 1.2392233720369E+21

PHP'de tamsayılar varsayılan olarak onluk sayı sisteminde ifade edilirler. Fakat, tamsayıarı  farklı sayıs sistemlerinde de ifade etmek mümkündür. PHP, ikilik, sekizlik, onaltılık sayı sistemlerinde tamsayıları ifade etmeeye imkan tanır.

1. İkilik Sayı Sistemi
   PHP'de ikilik sayı sisteminde bir tamsayı ifade etmek için bu sayının başına 0b koyulur.

   0b0001
   0b10101
   0b010001
   0b0102    // 2 ikilik sayı sisteminin bir rakamı değildir.

2. Sekizlik Sayı Sistemi
    PHP'de sekizlik sayı sisteminde bir tamsayı ifade etmek için bu sayının başına 0 koyulur.
    012345
    066778    // 8 olmaz.
    012345
    0895454   // Hatalı, 8 ve 9 sekizlik tabanın rakamları değllerdir

3. Onaltılık Sayıs Sitemi
    PHP'de onaltılık sayı sisteminde bir tamsayı ifade etmek için bu sayının başına 0x koyulur.
    0xAF123
    0xABCDEF
    0xG123    // G, onaltılık sayı siteminde bir rakam değilidr.
    
   
   #+BEGIN_SRC php
     $sayi = 0b100;    // 0*2^0  +  0*2^1  +  1*2^2  = 4
echo $sayi;
#+END_SRC

#+RESULTS:
: 4

 #+BEGIN_SRC php
     $sayi = 016;    // 6*8^0  +  1*8^1 = 6 + 8 = 14
echo $sayi;
#+END_SRC

#+RESULTS:
: 14

 #+BEGIN_SRC php
     $sayi = -0xFF;    // F*16^0  +  F*16^1 = 15 + 15*160 = 15 + 240 = 255
echo $sayi;
#+END_SRC

#+RESULTS:
: -255

**** Floating-Point Sayılar (Reel Sayılar)
Onndalıklı sayılar formunda reel sayıoları ifade etmek için kullanılan veri türüdür .

1.456
-3.4512
1.45E12    // = 1.45*10^12
0.3454E-21     // 0.3454*10^-21

#+BEGIN_SRC php
    $a = 0.17;
    $b = 1 - 0.83; //0.17
  printf('%.50f', $a);

    if($a == $b ){
     echo 'a ile b eşit';
    }
    else {
     echo 'a ile b eşit değil';
    }
#+END_SRC

#+RESULTS:
: .50fa ile b eşit değil

*** Büyük Küçük Harfe Duyarlılık
:PROPERTIES:
:NOTER_PAGE: (62 . 0.7670720299345182)
:TOC:      :depth 0
:END:
Kullanıcılar tarafından tanımlanan sınıf isimleri, yerleşik yapılar ve anahtar kelimeler(~echo~, ~while~, ~class~, ~if~ gibi) büyük-küçük harfe duyarlı değildir.

Örneğin aşağıdaki üç satırın birbirinden farkı yoktur.
#+BEGIN_SRC php
echo("hello, world");
ECHO("hello, world");
EcHo("hello, world");
#+END_SRC

Fakat, değişken isimleri büyük-küçük harfe duyarlıdır. =$Ad$=, =$ad=, =$AD= değişkenleri birbirinden farklıdır ve farklı değerler alabilirler.
*** Boşluk ve Yeni Satır Karakterleri
:PROPERTIES:
:NOTER_PAGE: (64 . 0.5893358278765201)
:END:
PHP'de deyimler arasında kullanılan boşluk veya yeni satır karakterleri yorumlayıcı tarafından dikkate alınmaz. 
*** Direkt Değişmez Veriler(Literals)
:PROPERTIES:
:NOTER_PAGE: (71 . 0.15715622076707203)
:END:
Programlama dili içerisinde tek başına bir veri taşıma yeteneğine sahip yapılardır. Program içerisinde kullanılan tamsayılar ve kayan noktalı sayılar, tırnak içerisinde yazılan metin ifadeler, =true=, =false=, =null= direkt değişmez verilere örnektirler.
#+BEGIN_EXAMPLE
2001
0xFE
1.343
"Merhaba Dünya"
'Selam'
true
null
#+END_EXAMPLE


*** xzxx
:PROPERTIES:
:NOTER_PAGE: 95
:END:
**** Expressions(İfadeler)
Bir ya da daha fazla değişkenden, operatörden (örn. +) veya fonksiyondan meydana gelen ve programlama dili tarafından yorumlandığında bir değer döndüren ifadelerdir.
=4=, =$a+5=, ="Yaz"= ifadelere örnektir.

**** Statements(Deyimler)
Programlama dilinin cümleleridir. Programın en küçük birimleridir. Deyimler ifadelerden oluşur.  PHP'de deyimlerin sonuna noktalı virgül(=;=) karakteri gelir.
*** Operatörler
Operatörler, bir veya birden fazla değeri herhangi bir işleme sokan ve yeni bir değer üreten yapılardır. Operatörlerin üzerinde işlem yaptığı değerlere operand denir.
Operatörler aslında fonksiyonların daha kullanışlı halleri olarak düşünülebilir.
Çoğu operatör operandlarının değerini değiştirmemesine rağmen bazı operandlar operandlarının değerlerini değiştirir.
**** Atama Operatörleri
/=/ atama operatörüdür. Bir çok kez değişkenin önceki değeri işlem yapıp elde edilen sonucun yine aynı değişkene atanmasını isteyebiliriz. 

Atama operatörü olan ~=~ operatörünün önce sağ tarafı çalıştırılır ve elde edilen değer operatörün sol tarafındaki değişkene atanır.

#+BEGIN_SRC php
  $sayi_toplama = 5;
  $sayi_toplama = $sayi_toplama + 10;

  $sayi_carpma = 7;
  $sayi_carpma = $sayi_carpma * 10;

  $sayi_cikarma = 8;
  $sayi_cikarma = $sayi_cikarma - 9;

  $sayi_bolme = 80;
  $sayi_bolme = $sayi_bolme / 8;

  $sayi_mod = 17;
  $sayi_mod = $sayi_mod % 5;


  var_dump($sayi_toplama);
  var_dump($sayi_carpma);
  var_dump($sayi_cikarma);
  var_dump($sayi_bolme);
  var_dump($sayi_mod);

#+END_SRC

#+RESULTS:
: int(15)
: int(70)
: int(-1)
: int(10)
: int(2)

#+BEGIN_SRC php
  // urun_fiyati = urun_ham_fiyati + urun_ham_fiyati * 0.2
  // urun_fiyati_kdv = urun_fiyati + urun_fiyati * 0.18
  $urun_fiyat = 100;
  $urun_fiyat = $urun_fiyat + $urun_fiyat * 0.2;
  $urun_fiyat = $urun_fiyat + $urun_fiyat * 0.18;
  var_dump($urun_fiyat);
#+END_SRC 

#+RESULTS:
: float(141.6)

#+BEGIN_SRC php
  // urun_fiyati = urun_ham_fiyati + urun_ham_fiyati * 0.2
  // urun_fiyati_kdv = urun_fiyati + urun_fiyati * 0.18
  $urun_fiyat = 100;
  $urun_fiyat += $urun_fiyat * 0.2;
  $urun_fiyat += $urun_fiyat * 0.18;
  var_dump($urun_fiyat);
#+END_SRC 

**** Operatörlerin Öncelik Sırası
Birden fazla operatör bir ifade içinde yer aldığında, hangi operatöre ait işlemin önce yapılacağına göre ifadenin değeri değişebilir. Dolayısıyla net değer için hangi operatörün hangisinden önce yapılacağı bilinmelidir. PHP yorumlayıcısı operatörlerden hangisinin diğerinden önce yapılacağını tespit etmek için aşağıdaki operatör öncelik tablosounu kullanır.

| Sıra | Birleşim | Operatör          | Operasyon             |
|   24 | N        | clone, new        | Yeni nesne oluşuturur |
|   23 | L        | [                 | Dizi elemanına erişim |
|   22 | R        | **                | Üst alma              |
|   21 | R        | ~                 | Bitsel Hayır          |
|   21 | R        | ++                | Bir arttırma          |
|   21 | R        | --                | Bir azaltma           |
|   21 | R        | (int), (bool),... | Tür dünüşümü          |
|   21 | R        | @                 | Hataları gizleme      |
|      |          |                   |                       |
** Kontrol Yapıları
*** for Döngüsü
#+BEGIN_SRC php
  for(baslangic_ifadesi; dongu_kosulu; adim_sonu_ifadesi)
    tek_deyim;
#+END_SRC

#+BEGIN_SRC php
  for(baslangic_ifadesi; dongu_kosulu; adim_sonu_ifadesi) {
      deyim1;
      deyim2;
  }
#+END_SRC

#+BEGIN_SRC php
  for(baslangic_ifadesi; dongu_kosulu; adim_sonu_ifadesi):
      deyim1;
      deyim2;
  endfor;
#+END_SRC

Döngüler, belirli bir kod bloğunu tekrar tekrar çalıştırmaya yarayan yapılardır. Bu kod bloğuna döngünün *gövdesi* denir. ~for~ döngüsünün gövdesi tek bir deyimden oluşuyorsa, bu gövdeyi küme parantezleri arasına almamız gerekmez.
Fakat gövde birden fazla deyimden oluşuyorsa parantezler arasına yazılmalıdır.
**** For Döngüsünün Çalışma Şekli
1. Program ~for~ döngüsünün başladığı satıra geldiğinde, önce baslangic_ifadesi bölümünü çalıştırır. Bu çalıştırma işlemi koşulsuz ve bir kereye mahsus yapılır.
2. dongu_kosulu mantıksal bir ifade ya da boolean türüne dönüşebilen bir ifade olmak üzere, dongu_kosulu ifadesinin =true= değer döndürüp döndürmediğine bakılır. Eğer =true= değer dönüyorsa, döngünün gövdesi baştan sona çalıştırılır.
3. Gövdenin çalıştırılması işlemi bittikten sonra =adim_sonu_ifadesi= bölümü çalıştırılır. =adim_sonu_ifadesi= her döngü gövdesi çalıştırma işleminden sonra tekrar çalıştırılır.
4.  Program, ~for~ satırına geri döner ve döngü koşulunun =true= değer döndürüp döndürmediğine bakılır. Dönen değer =true= ise 2. ve 3. adım tekrarlanır. =false= ise program, döngü gövdesinin bittiği satırdan sonraki satırdan itibnaren çalışmaya devam eder.
 #+BEGIN_SRC php
   echo "Döngüden önceki satır."
   for ($i = 1; $i <= 3; $i++) {
       echo $i;
       echo "Bitti";
   }
echo "Döngünün bitiş satırı";
 #+END_SRC

 Program 2. satıra geldiğinde, programımız for döngüsünün başlangıç ifadesi adı verilen ve ilk noktalı virgüle kadar olan ifadeyi hiçbir koşul gözetmeksizin çalıştıracaktır. O halde, 2. satıra gelindiğinde $i=1 olacaktır.

Yine 2. satırda, bu işlemini hemen sonrasında döngünün çalışıp çalışmayacağını anlamak için, birinci ; ile ikinci ; arasında kalan ifadenin sonucuna bakılır. Eğer bu sonuç true ise döngünün kod bloğu çalıştırılmaya başlanır ve program 3.satırdan(döngünün kod bloğunun başı) 4. satıra(döngünün kod bloğunun sonu) kadar çalıştırılır.

satır çalıştıktan sonra döngünün kod bloğu baştan sona çalıştırılmış olur. Program tekrar for satırına geri dönüp for deyiminin ikinci ; karakterinden sonra gelen bitiş ifadesi çalıştırır.

Sonrasında tekrar koşul ifadesine bakılır. Eğer koşul ifadesi doğru ise aynı işlemler tekrarlanır. Eğer koşu ifadesi false ise döngünün kod bloğunun bittiği yerden(6. satır) program devam eder.

#+BEGIN_SRC php
echo "Döngüden önceki satır.\n";
for ($i = 1; $i <= 3; $i++) {
    echo "Adım $i\n";

}
echo "Döngüden sonraki satır.\n";
#+END_SRC


#+BEGIN_SRC php
  $yazi = "MerhabaDünya";
  $bas=8;
  $son=10;
  for($i=$bas; $i<=$son; $i++) {
      echo $yazi[$i];
  }
#+END_SRC

#+RESULTS:
: ün

*** foreach Döngüsü
Dizi türünden değişkenlerin yada değerlerin elemanlarını taramak için kullanılır. Bu döngünün 
her bir adımında, dizinin önceki adımda erişilen elemanını takip eden elemanına döngü kod bloğu 
içerisinde bir değişken vasıtasıyla erişebiliriz.

Çoğu dizinin elemanlarına for döngüsü yardımıyla erişilebilir. Aşağıdaki örneği inceleyelim.
#+BEGIN_SRC php
$dizi=[3,9,2,5];
for($i=0; $i<count($dizi); $i++) {
    echo $dizi[$i];
    echo "\n";
}
#+END_SRC

#+RESULTS:
: 3
: 9
: 2
: 5
Anahatar-Değer formunda verilen dizileri for döngüsü baştan sona taramak bazen güç olabilir. Aşağıdaki örneği inceleyelim.
#+BEGIN_SRC php
  $ogrenciler=[
      1234 => "Ali Veli",
      2345 => "Fatma ŞAHİN",
      3564 => "Seyfi DOĞAN"];

  for($i=0; $i<=3564; $i++) {
      if(isset($ogrenciler[$i])) {
          echo $ogrenciler[$i];
          echo "\n";
      }
  }
#+END_SRC

#+RESULTS:
: Ali Veli
: Fatma ŞAHİN
: Seyfi DOĞAN

Aynı örneği foreach döngüsü ile yapalım.
#+BEGIN_SRC php
  $ogrenciler=[
      1234 => "Ali Veli",
      2345 => "Fatma ŞAHİN",
      3564 => "Seyfi DOĞAN"];

  foreach($ogrenciler as $ogrenci) {
          echo $ogrenci;
          echo "\n";
  }
#+END_SRC

#+RESULTS:
: Ali Veli
: Fatma ŞAHİN
: Seyfi DOĞAN


  #+BEGIN_SRC php
  $dizi=[3,9,2,5];
  for($i=0; $i<count($dizi); $i++) {
      echo $dizi[$i];
      echo "\n";
  }

  foreach($dizi as $eleman) {
      echo "$eleman\n";
  }
#+END_SRC

foreach döngüsünde, istenildiği takdirde dizi anahtarlarına da ulaşılabilir. 
#+BEGIN_SRC php
$ogrenciler=[
    123 => "Ali Veli",
    125 => "Fatma Şahin",
    345 => "Suat AK"
    ];

foreach($ogrenciler as $numara => $adsoyad) {
    echo "$adsoyad isimli öğrencinin numarası $numara\n";
}
#+END_SRC

#+RESULTS:
: Ali Veli isimli öğrencinin numarası 123
: Fatma Şahin isimli öğrencinin numarası 125
: Suat AK isimli öğrencinin numarası 345
*** try-catch Yapısı
try-catch, hata ve istisna tespiti için kullanılan bir yapıdır. try-catch yapısı,
#+BEGIN_SRC php
    try {
      // Hata yada istisna üretebilecek kod
    }
    catch (Exception $error) {
      // Hata durumunda yapılacaklar
    }
#+END_SRC

#+BEGIN_SRC php
  try {
      $dbhandle = new PDO('mysql:host=localhost; dbname=library', $username, $pwd);
      doDB_Work($dbhandle); 
      $dbhandle = null; 
  }
  catch (PDOException $error) {
      print "Error!: " . $error->getMessage() . "<br/>";
      die("Hata");
  }
echo "devam";
#+END_SRC

Program try bloğu içerisindeki kodları çalıştırmayı dener. Eğer bu çalıştırma işlemi sorunsuz olarak gerçekleşirse, program direkt olarak ~echo "devam"~ satırına atlar ve çalışmaya devam eder. Fakat, try bloğu içerisinde bir sorunla karşılaşılırsa catch bloğu işletilir. catch bloğu, parametre olarak Exception nesnesi alır ve bu nesne try bloğunda oluşan sorunu tanımlayabilmek için bize yardımcı olur.
*** exit Deyimi
~exit~ deyimi, programın çalışmasını sonlandırır. 
~exit~ deyimi, ~exit 3~ şeklinde parametre alır. Bu parametre, programın doğru çalışıp çalışmadığı hakkında bize bilgi verir.
Örneğin, ~exit(0)~ veya ~exit 0~ ile programı sonlandırmak, programın başarılı bir şekilde çalıştığı anlamına gelir.
~exit~ fonksiyonuna string türünde parametre verildiğinde, program bu parametreyi yazdırarak çalışmasını durdurur.
~exit~ fonksiyonun diğer bir takma ismi ~die~ fonksiyonudur. Bu iki fonksiyon birbiri yerine kullanılabilir.

#+BEGIN_SRC php
  for($i=1; $i<=40; $i++) {
      if($i==35) {
          return;
      }
      echo "$i\n";
  }
  echo "Bitti";
#+END_SRC

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
#+end_example
*** include Deyimi
Harici dosyalar ~include~ deyimi ile herhangi bir dosyaya eklenebilir. Bu eklenen kodlar, eklendiği yerde çalıştırılır. Dolayısıyla eklenenen bu dosyadaki değişkenleri ve fonksiyonları eklediğimiz dosya içerisinde kullanabiliriz.
~include~ deyimi aşağıdaki şekilde kullanılır.

#+BEGIN_SRC  php
  include "klasor1/dosya1.php";
  include "dosya.php";
  include("ekle.php");
  include("abc.html");
  include "http://www.abc.com/xyz.php"
#+END_SRC

~include~ deyiminden sonra gelen ve koda eklenecek olan dosyayı gösteren parametre, bir dosya yolu olmak zorundadır. Bu dosya yolu, PHP'nin ayarlarında yer alan, ~include_path~ klasörü içinde aranır. İlgili dosya, ~include_path~ ayarında belirtilen klasörlerde bulanamazsa, ~include~ deyiminin kullanıldığı PHP dosyasının bulunduğu klasöre bakılır. Eğer, ilgili dosya belirtilen konumlarda bulunamazsa, PHP bu dosyanın bulunamadığına dair bir uyarı(Warning) mesajı verecektir. Fakat, ana kod programımızın çalışması kesintiye uğramayacak ve programımız ~include~ deyiminden sonraki satırdan çalışmaya devam edecektir.

#+BEGIN_VERSE
PHP'den, *Warning* tipinde bir bildirim aldığımızda, programın çalışması kesintiye uğramadan devam edecektir.
#+END_VERSE

Mesela, PHP ayarlarında, ~include_path=/home/php/~ olsun.
Ben, ~/var/www/localhost/htdocs/~ klasörü içerisindeki ~deneme.php~ dosyasını düzenliyor olayım.

deneme.php
#+BEGIN_SRC php
include "abc.php"
 #+END_SRC

*** require Deyimi
~require~ deyimi, ~include~ deyimi ile aynı işleve sahiptir. Kullanım şekli ve amacı ~include~ ile aynıdır. İkisi arasındaki tek fark, ~require~ deyimi, ~require~ ile eklenecek olan dosyayı bulamaması durumunda, bir *Fatal Error* üretecektir. PHP, *Fatal Error* bildirimi aldığında, programın çalışmasına o noktada son verecektir. Dolayısıyla, var olmayan bir dosyayı ~include~ ile programımıza dahil ettiğimizde, bir *Warning* bildirimi alırız ve programımız çalışmaya devam eder. Aynı şekilde, var olmayan bir dosyayı ~require~ ile programımıza dahil ettiğimizde bir *Fatal Error* bildirimi alırız ve program o noktada sonlanır, çalışmaya devam etmez.

*** return Deyimi
~return~ deyiminin fonksiyonlar içinde kullanımını fonksiyonlar konusunda işleyeceğiz. ~return~ deyimi ana program kodu içerisinde kullanıldığında programı sonlandırır. Bu bağlamda düşünüldüğünde ~exit~ ile aynı işleve sahip olacaktır. 

#+NAME: ~return~ deyiminin fonksiyon gövdesi dışında kullanılması.
#+BEGIN_SRC php :exports both
  $deneme="abc";
  if($deneme=="abc") {
      for($i=0; $i<=5; $i++) {
          if($i==3) {
              return;
          }
          echo $i."- Döngü içi\n";
      }
      echo "Döngü dışı";
  }
  echo "İf dışı";
#+END_SRC

#+RESULTS: ~return~ deyiminin fonksiyon gövdesi dışında kullanılması.
: 0- Döngü içi
: 1- Döngü içi
: 2- Döngü içi

Yukarıdaki programda görüldüğü gibi, ~return~ deyimi ~break~ deyiminden farklı olarak bir bloğun çalışmasını değil tüm programın çalışmasını sonlandırır.

~return~ anahtar kelimesi, ~include~ ve ~require~ içinde de kullanılabilir. ~include~ deyiminin parametresi olan dosyaya *dahil edilen dosya*, ~include~ deyiminin kullanıldığı dosyaya da *ana kod dosyası* şeklinde tanımlayalım. ~return~ deyimi dahil edilen dosya içerisinde direkt kullanıldıysa (yani bir fonksiyon gövdesinde kullanılmadıysa), kullanıldığı satırda dahil edilen dosyanın çalışmasını sonlandırır. Program, ana kod dosyasının, ilgili ~include~ deyiminden sonraki satırdan itibaren çalışmaya devam edecektir. Diğer bir deyişle, ~return~ deyiminin kullanıldığı satırdan itibaren programın çalışmasını sırasını ana kod dosyasına devreder.
Aynı durumlar ~require~ içinde geçerlidir.

** Fonksiyonlar
*** Fonksiyonun Tanımı
Tekrar etmesi muhtemel belirli bir görevi yerine getiren kod bloğunun isim verilmiş haline *fonksiyon* denir.
Program içerisinde, isim verilen bu kod bloğunun görevi gerektiğinde, sadece ismi ile çağırılıp çalıştırılabilir.

İsim verilen bu kod bloğu(fonksiyon), ayrıca icra edeceği görevi özelleştirebilmek için *parametre* adı verilen değer veya değerleri kullanılabilir.

Ayrıca, icra edilen görev tamamlandığında, görevin bir çözümü olarak değer veya değerler döndürebilir. Bu değere *fonksiyonun dönen değeri* denir ve bu şekildeki fonksiyonlara *değer döndüren fonksiyonlar* denir.

Fonksiyonlar, matematiksel fonksiyonlar gibidir. Örneğin ~f(x)=x*x+2~ fonksiyonunu düşünürsek, burada ~x~ fonksiyonun bir parametresidir ve fonksiyon bir parametrelidir. ~x*x+2~ fonksiyonun hem icra ettiği görev hem de dönen değeridir. Örneğin ~x=3~ alınırsa, fonksiyonun dönen değeri ~11~ olur.
Mesela, ~f(x,y)=x+y~ fonksiyonu iki parametrelidir ve bu iki parametrenin toplamını döndürür. 
*** Fonksiyonların Önemi
Aynı işlevi gören kod bloğu, işlevin gerektiği her yerde bir bütün olarak kullanılması gerekecekti. Kod bloğunuzda bir hata tespit ettiğinizde veya bir geliştirme yapmak istediğinizde, programınızın çeşitli yerlerine eklemiş olduğunuz bu kod bloklarını bulup gerekli düzeltmeleri veya iyileştirmeleri her biri için teker teker yapmanız gerekecek.
Bu kod bloğu fonksiyon olarak tanımlanmış olsaydı, sadece fonksiyonun tanımlandığı kod bloğunda yapılan değişiklikler fonksiyonun çağırıldığı her noktaya etki eder.
Ayrıca, programınızın uğraştığı problemi, küçün birimlere ayırarak baş çıkması daha kolay hale getirir. 
*** Fonksiyon Türleri
**** Yerleşik(Built-In) Fonksiyonlar
Tüm programcılar tarafından kullanılması muhtemel bazı görevler(çıktı yazdırma, karekök alma gibi), dili oluşturanlar tarafından yerleşik olarak fonksiyon haline getirilmiştir. Herhangi bir tanımlama yapılmadan, programcı bu fonksiyonları kullanabilir. Örneğin, ~echo~, ~var_dump~, ~sqrt~ yerleşik fonksiyonlardır.
**** Kullanıcı Tanımlı Fonksiyonlar
Programcı tarafından tanımlanan fonksiyonlardır. 
*** Fonksiyonların Tanımlanması
Bir PHP fonksiyonu,

#+BEGIN_SRC php
  function fonksiyon_ismi(parametre1, parametre2, ...) {
      deyim_veya_deyimler;
  }
#+END_SRC

Fonksiyon isminden sonra gelen parantezler arasına yazılan ve virgüllerle birbirinden ayrılan yapılar fonksiyonun parametreleridir. Fonksiyonun sıfır veya daha fazla parametresi olabilir.

Deyim bölümünde HTML kodları da kullanılabilir. Hatta hiç PHP kodu içermeyen Fonksiyonlarda oluşturulabilir. Örneğin,
#+BEGIN_SRC php
  <?php
  function sutun()
  { ?>
      </td><td>
  <?php } ?>
#+END_SRC

Yukarıdaki ~sutun~ fonksiyonunun hiç parametresi yoktur.
Fonksiyonlar çoğu zaman değer döndürürler. Fonksiyonun kod bloğunda değer döndürme eylemi ~return~ deyimi ile gerçekleştirilir. ~return~ deyimi, ~return ifade~ veya ~return $degisken~ şeklinde kullanılır. Fonksiyon çalışırken ~return~ deyimi ile karşılaşırsa, fonksiyonun çalışması sonlanır ve ~return~ ile dönen değer fonksiyonun çağırıldığı deyime aktarılır. Bir fonksiyon içerisinde birden fazla ~return~ deyimi kullanılabilir.

  #+BEGIN_SRC php
    function birlestir($sol, $sag) {
        $bilesik = $sol . $sag;
        return $bilesik;
    }
    $adsoyad = birlestir("Ali", "Veli");
    echo $adsoyad;
  #+END_SRC

  #+RESULTS:
  : AliVeli


Yukarıdaki fonksiyon, ~$sol~ ve ~$sag~ adlı iki parametre alır ve bunların birleşmesi ile elde ettiği metni döndürür. ~return~ deyiminden sonra ifadelerde kullanılabileceği için aynı fonksiyon daha sade,

  #+BEGIN_SRC php
    function birlestir($sol, $sag) {
        return $sol . $sag;
    }
  #+END_SRC

şeklinde tanımlanabilir.
Tanımlanan fonksiyonlar, programın herhangi bir yerinde kullanılabilir.

#+BEGIN_SRC php
  echo birlestir("Hasan", "ÖKTEN");

  function birlestir($sol, $sag) {
      return $sol . $sag;
  }
  #+END_SRC

  #+RESULTS:
  : HasanÖKTEN

**** Fonksiyon İsimlendirme Kuralları
- Fonksiyon isimleri, harf, alt tire, rakam sembollerinin bir veya daha fazla kombinasyonundan oluşmalıdırlar. 
- Fonksiyon isimleri harf veya _ ile başlamalıdır. Rakam ile başlayamazlar. 
- Fonksiyonları isimleri büyük-küçük harflere duyarlı değildir.

  #+BEGIN_EXAMPLE
  #+BEGIN_SRC php
  8tas() // Yanlış fonksiyon ismi. (Rakam ile başlamış)
  -aktif(5) // Yanlış fonksiyon ismi. (- ile başlamış)
  bas harfi al("Ali") // Yanlış fonksiyon ismi. (Boşluk içeriyor)
  buyut("ali") // Doğru fonksiyon ismi.
  _aktifet($pasif) // Doğru fonksiyon ismi.
  altiniciz("metin"); // Yandaki üç
  AltiniCiz("metin"); // fonksiyonda aslında
  ALTINICIZ("metin"); // aynı fonksiyondur. Aynı işleve sahiptirler.
  #+END_SRC
  #+END_EXAMPLE
  
*** Fonksiyonların Çağırılması
Tanımlanmış fonksiyonlar, programın herhangi bir yerinde isimleri ile çağırılabilirler. Ayrıca, fonksiyon isminden sonra varsa, iki parantez arasına parametreleri yazılır.
~echo("Yaz")~, ~kareal(3)~, ~tabloyap()~

Fonksiyonlara verilen parametreler, fonksiyonun tanımının gerektirdiği sayıda ve sırada olmalıdır.
#+BEGIN_SRC php
  function cikar($eksilen, $cikan) {
      return $eksilen-$cikan;
  }
#+END_SRC
Örneğin yukarıda tanımlanan ~cikar~ fonksiyonu, ~eksilen~ ve ~cikan~ isimlerine sahip iki parametre almaktadır. Bu durumda, ~cikar~ fonksiyonu, ~cikar(5)~ veya ~cikar(1,2,3)~ şeklinde çağırılmaya çalışıldığında hata oluşur. Çünkü ~cikar~ fonksiyonu tanımı gereği tam olarak iki parametre almak zorundadır.
Benzer şekilde, 10 sayısından 7 sayısını çıkarmak için ~cikar~ fonksiyonunu kullandığımızı düşünelim. Eğer fonksiyonu, ~cikar(7,10)~ şeklinde kullanırsak, program hata üretmemesine rağmen, parametreleri yanlış sırada kullandığımız için hesaplama hatası ile karşı karşıya kalırız.

**** Yerleşik Fonksiyon Örnekleri
***** strlen
Metin türünden bir değerin toplam karakter sayısını döndürür. ~strlen~ fonksiyonun icra ettiği görev düşünüldüğünde, parametre sayısının bir olduğu ve tamsayı türünden bir değer döndürdüğü kolaylıkla anlaşılabilir. Fakat bu fonksiyon, karakter sayısını döndürecek olduğu metin içerisinde, Türkçe karakterler gibi Unicode karakterler mevcutsa yanlış değerler döndürmektedir. 
***** sin
~sin~ fonksiyonun dökümantasyonuna incelendiğinde, =sin(float $num) : float= biçiminde tanımlandığı görülebilir.
=float $num=, ~sin~ fonksiyonunun =$num= isimli bir parametre alacağını ve bu parametrenin =float= türünden olacağını belirtmektedir. Ayrıca, ~sin~ fonksiyonu sadece bir tane parametre alır ve bu parametrede =$num= parametresidir.
=:= karakterinden sonra gelen sözcük ise, fonksiyonun döndürdüğü değişken türünü göstermektedir. O halde =sin= fonksiyonu =float= türünden bir değer döndürmektedir.
***** substr
~substr~ fonksiyonu, =substr(string $dizge, int $başlangıç [,int $uzunluk]) : string= şeklinde tanımlanmıştır. Fonksiyon tanımlamalarında, =[]= arasında verilen parametreler *opsiyonel* yani seçimliktir. Bu parametreler fonksiyona verilmese de fonksiyon çalışır. O halde =substr= fonksiyonu, iki zorunlu ve bir seçimlik parametreye sahiptir. Zorunlu parametreler =$dizge= ve =$başlangıç= parametreleridir. =$dizge= kesit alacağınız metni temsil eder ve =$başlangıç= ise kesit alma işleminin hangi sıradaki karakterden başlanarak yapılacağını belirtir.
Eğer =$uzunluk= parametresi kullanılmazsa, kesit alma işlemi belirtilen sıradan metnin son karakterine kadar yapılır. =$uzunluk= parametresi kullanılırsa, kesit alma işlemi belirtilen sıradaki karakterden, =$uzunluk= kadar karakter ilerlenerek yapılır.

#+BEGIN_SRC php
  $metin="Merhaba";
  echo substr($metin, 2); // $uzunluk parametresi olmadığından metnin sonuna kadar ilerledi.
  echo "\n";
  echo substr($metin, 3, 3) 
#+END_SRC

#+RESULTS:
: rhaba
: hab

*** Değişken Kapsamı
Eğer programınızda hiçbir fonksiyon kullanmıyorsanız, bir değişkeni oluşturduktan satırdan sonra herhangi bir yerde bu değişkeni kullanabilirsiniz.
Fakat fonksiyonlar içinde tanımlananan değişkenler(yerel değişkenler), özel teknikler kullanılmadıysa sadece fonksiyon içinde geçerli olurlar.
Benzer şekilde genel olarak, programın ana kod parçasında veya bir başka fonksiyonda tanımlanan değişkenler, diğer fonksiyonlar içerisinde kullanılamazlar.
Bir değişkenin geçerli olduğu(kullanılabildiği) kod parçasına, o değişkenin *kapsamı* denir.

#+CAPTION: HelloWorldCaption
#+srcname: HelloWorldSrcName
#+BEGIN_SRC php
  $a = 3;

  function foo()
  {
      $a += 2;
      $b = 5;
  }
  foo();
  echo $b;
  echo $a;
#+END_SRC

#+RESULTS: HelloWorldSrcName
: 3

Yukarıdaki programın çıktısı 3 olacaktır. Baştaki ~$a~ değişkeni ana program bloğunda tanımlanmıştır. ~foo~ fonksiyonu içinde ~$a~ değişkeninin değerini kullanmak mümkündür fakat bu ancak ~$a~ değişkenin ~foo~ fonksiyonuna parametre olarak verilmesiyle olur. Bu durumda bile aslında ~foo~ fonksiyonuna ~$a~ değişkeninin kendisini değil o anki değerinin bir kopyasını göndermiş oluyoruz. Benzer şekilde, ~foo~ fonksiyonun içindeki ~$a~ değişkeni de ana kod bloğunda kullanılamaz. Ana kod parçasındaki ~$a~ değişkeni ile ~foo~ fonksiyonu içindeki ~$a~ değişkeninin birbirleriyle hiçbir ilgisi yoktur. Bunlar kapsamları farklı olan iki farklı değişkendirler.
Fonksiyon içinde tanımlanan değişkenlerin kapsamları en fazla fonksiyonun kod bloğu kadar olur. Bu kapsama *fonksiyon seviyesi kapsam* denir. Örneğin ~foo~ fonksiyonu içinde tanımlanan ~$a~ değişkenini ömrü fonksiyon kod bloğunun kapama parantezine kadardır.
Fonksiyonların ve sınıfların dışında tanımlanan değişkenlerin kapsamına *global seviye kapsam* denir.
*Super global seviye kapsama* sahip değişkenler ise her iki kapsam içinde kullanılabilirler.

*** Global Değişkenler
Global kapsamda yer alan bir değişkeni bir fonksiyon içinde kullanmak için ~global~ anahtar deyimi kullanılır. Bir önceki örneği bu şekilde düzenlersek, ana kod parçasında ve ~foo~ fonksiyonu içinde kullandığımız ~$a~ değişkenleri artık aynı değişken olacaktır. 

#+BEGIN_SRC php
  $a = 3;
  function foo()
  {
      global $a;
      $a += 2;
  }
  foo();
  echo $a;
#+END_SRC

#+RESULTS:
: 5

*** Static Değişkenler
Normalde, bir fonksiyon her çağırıldığında fonksiyonun içindeki değişkenler tekrardan tanımlanır. Yani, değerlerini saklamazlar. Aşağıdaki örneği inceleyelim.
#+BEGIN_SRC php
  function deneme()
  {
      $b +=3; // $b=$b+3; $b=0+3 = 3; 
      return $b;
  }
  echo deneme();
  echo "\n";
  echo deneme();
#+END_SRC

#+RESULTS:
: 3
: 3

Örnekte görüldüğü gibi, =$b= değişkeninin kapsamı =deneme= fonksiyonunun gövdesi olduğundan dolayı, değişken her fonksiyon çağırılışında tekrardan oluşturuluyor. =deneme= fonksiyonu ilk defa çağırıldığında =$b= en son olarak =3= değerini aldı ve fonksiyon görevini bitirdiğinde =$b= değişkeni bellekten silindi.  =deneme= fonksiyonu tekrar çağırıldığında, =$b= değişkeni yeniden oluşturuldu ve varsayılan olarak =0= değerini aldı.
Bir değişkeni; fonksiyonun her çağırılışında, bu değişkenin fonksiyonun önceki çağırılışlarında aldığı değerleri kaybetmeden kullanmak istiyorsak ~static~ anahtar kelimesini kullanmalıyız. Aşağıdaki örnekte bir fonksiyonun kaç defa çağırıldığını statik değişkenler yardımıyla bulacağız.
#+BEGIN_SRC php :exports both
  function deneme()
  {
      static $cagirilma_sayisi=0;
      $cagirilma_sayisi++;
      echo "deneme() fonksiyonunun {$cagirilma_sayisi}. çağırışınız.\n";
  }
  deneme();
  deneme();
  deneme();
#+END_SRC

#+RESULTS:
: deneme() fonksiyonunun 1. çağırışınız.
: deneme() fonksiyonunun 2. çağırışınız.
: deneme() fonksiyonunun 3. çağırışınız.

#+BEGIN_SRC php :exports both
$cagirilma_sayisi=16;
  function deneme()
  {
      static $cagirilma_sayisi=0;
      $cagirilma_sayisi++;
      echo "deneme() fonksiyonunun {$cagirilma_sayisi}. çağırışınız.\n";
  }
  deneme();
  deneme();
  deneme();
#+END_SRC

#+RESULTS:
: deneme() fonksiyonunun 1. çağırışınız.
: deneme() fonksiyonunun 1. çağırışınız.
: deneme() fonksiyonunun 1. çağırışınız.

*** Referans Değişkenler
Bir fonksiyona, değişkenin değerini değil, değişkenin bulunduğu bellek adresini kullanarak parametre olarak verebiliriz. Bu durumda, fonksiyon içinde bu referans değişkenine uygulanan tüm işlemler, değişkeni de doğrudan etkileyecektir.

#+BEGIN_SRC php :results value pp
   $sayi=15;
   function deneme(&$giren)
   {
       $giren +=3; // $b=$b+3; $b=0+3 = 3; 
       return $giren;
   }
   echo deneme($sayi); // $sayi değişkenin değeri 3 artar: 18
   echo "\n";
   echo deneme($sayi); // $sayi değişkeninin değeri 3 artat: 21
  echo "\n";
   echo $sayi; // $sayi değişkeninin en son değeri 21
#+END_SRC

#+RESULTS:
: 18
: 21
: 21


#+BEGIN_SRC php :results value pp
  $sayi=15;
  function deneme($giren)
  {
      $giren +=3; // $b=$b+3; $b=0+3 = 3; 
      return $giren;
  }
  echo deneme($sayi); // $sayi değişkenin değeri 3 artar: 18
  echo "\n";
  echo deneme($sayi); // $sayi değişkeninin değeri 3 artat: 18
echo "\n";
  echo $sayi; // $sayi değişkeninin en son değeri 21
#+END_SRC

#+RESULTS:
: 18
: 18
: 15
*** Varsayılan Parametreler
Fonksiyonda bazı parametrelerin seçimlik(opsiyonel) olması mümkündür. Bu durumda, ilgili parametrelerin kullanılıp kullanımayacağının takdiri programcıyı bırakılmış olur. Bu şekildeki parametreler /seçimlik parametreler/ denir. Seçimlik parametresi olan bir fonksiyonda, bu seçimlik parametrenin kullanılmaması durumunda, foksiyonun tanımı içerisinde bu parametre için varsayılan bir değer kullanılmasını sağlayabiliriz.

#+BEGIN_SRC php :results value pp
  function uyrukYazdir($uyruk="T.C.") {
      echo "$uyruk\n";
  }
  uyrukYazdir("Almanya");
  uyrukYazdir("Belçika");
  uyrukYazdir();
#+END_SRC

#+RESULTS:
: Almanya
: Belçika
: T.C

- ~uyrukYazdir~ fonksiyonu kaç parametre alır?

Bir fonksiyonun birden fazla seçimlik parametresi olabilir. Seçimlik parametreler, seçimlik olmayan(zorunlu olan) parametrelerden sonra yazılmalıdırlar.


Bu kod hatalıdır. 
#+BEGIN_SRC php :results value pp
  function uyrukYazdir($uyruk="T.C", $yas) { // Seçimlik parametreler, parametre listesinde zorunlu olanlarda sonra gelmeliler. 
      echo "Yaşınız $yas, uyruğunuz $uyruk\n";
  }
  uyrukYazdir("Almanya", 17);
  uyrukYazdir("Belçika");
  uyrukYazdir(17);
#+END_SRC

#+RESULTS:


Bu kod doğrudur.
#+BEGIN_SRC php :results value pp
  function uyrukYazdir($yas, $uyruk="T.C") {
      echo "Yaşınız $yas, uyruğunuz $uyruk\n";
  }
  uyrukYazdir(12, "Almanya");
  uyrukYazdir(18);
#+END_SRC

#+RESULTS:
: Yaşınız 12, uyruğunuz Almanya
: Yaşınız 18, uyruğunuz T.C

- ~uyrukYazdir~ fonksiyonunun parametre sayısı 1 veya 2 olur.
  

Fonksiyon tanımında, birden fazla varsayılan değere sahip parametre bulunabilir. Örneğin aşağıdaki programda hem ~$yas~ hem de ~$uyruk~ seçimlik parametrelerdir. 
#+BEGIN_SRC php :results value pp
  function uyrukYazdir($yas=18, $uyruk="T.C") {
      echo "Yaşınız $yas, uyruğunuz $uyruk\n";
  }
  uyrukYazdir(12, "Almanya");
  uyrukYazdir(20);
  uyrukYazdir();
#+END_SRC

#+RESULTS:
: Yaşınız 12, uyruğunuz Almanya
: Yaşınız 20, uyruğunuz T.C
: Yaşınız 18, uyruğunuz T.C

*** Parametre Fonksiyonları
Fonksiyonun tanımalama gövdesinde kullanabileceğiniz ve fonksiyonun parametreleri bilgi veren yerleşik fonksiyonlardır.
- ~func_get_args()~ : Bu fonksiyon, başka bir fonksiyonun gövdesinde kullanıldığında o fonksiyonun bütün parametrelerinden oluşan bir dizi döndürür.
- ~func_num_args()~ : Bu fonksiyon, başka bir fonksiyonun gövdesinde kullanıldığında o fonksiyonun toplam parametre sayısını döndürür.
- ~func_get_arg($sira)~ : Bu fonksiyon, başka bir fonksiyonun gövdesinde kullanıldığında o fonksiyonun ~$sira~ sırasındaki parametresini döndürür.

  #+BEGIN_SRC php :results value pp
    function bilgiler($kimlikno, $dogumtarihi) {
        $toplam_parametre_sayisi = func_num_args();
        $parametrelerin_dizisi = func_get_args();
        $ikinci_parametre = func_get_arg(1);
        echo "Bu fonksiyonun $toplam_parametre_sayisi tane parametresi var\n";
        var_dump($parametrelerin_dizisi);
        echo "\n";
        echo "İkinci parametresi : $ikinci_parametre\n";
    }
    bilgiler(2345,1980);
    bilgiler(232323, 1999);
#+END_SRC

#+RESULTS:
#+begin_example
Bu fonksiyonun 2 tane parametresi var
array(2) {
  [0]=>
  int(2345)
  [1]=>
  int(1980)
}

İkinci parametresi : 1980
Bu fonksiyonun 2 tane parametresi var
array(2) {
  [0]=>
  int(232323)
  [1]=>
  int(1999)
}

İkinci parametresi : 1999
#+end_example

#+RESULTS:
#+begin_example
Bu fonksiyonun 2 tane parametresi var
array(2) {
  [0]=>
  int(2345)
  [1]=>
  int(1980)
}

İkinci parametresi : 1980
Bu fonksiyonun 2 tane parametresi var
array(2) {
  [0]=>
  int(232323)
  [1]=>
  int(1999)
}

İkinci parametresi : 1999
#+end_example

#+RESULTS:
#+begin_example
Bu fonksiyonun 2 tane parametresi vararray(2) {
  [0]=>
  int(2345)
  [1]=>
  int(1980)
}
İkinci parametresi : 1980Bu fonksiyonun 2 tane parametresi vararray(2) {
  [0]=>
  int(232323)
  [1]=>
  int(1999)
}
İkinci parametresi : 1999
#+end_example


#+BEGIN_SRC php :results value verbatim
  function bilgiler($kimlikno, $dogumtarihi=2000) {
      $toplam_parametre_sayisi = func_num_args();
      $parametrelerin_dizisi = func_get_args();
      $ikinci_parametre = func_get_arg(1);
      echo "Bu fonksiyonun $toplam_parametre_sayisi tane parametresi var\n";
      var_dump($parametrelerin_dizisi);
    echo "\n";
      echo "İkinci parametresi : $ikinci_parametre\n";
  }
  bilgiler(2345);
  bilgiler(232323, 1999);
#+END_SRC

#+RESULTS:
#+begin_example
Bu fonksiyonun 1 tane parametresi var
array(1) {
  [0]=>
  int(2345)
}

İkinci parametresi : 
Bu fonksiyonun 2 tane parametresi var
array(2) {
  [0]=>
  int(232323)
  [1]=>
  int(1999)
}

İkinci parametresi : 1999
#+end_example

*** Parametre Türünü Belirtme(Type Hinting)
PHP'de bir fonksiyon tanımlarken parametrelerinin hangi değişken türünden olacağını belirtmeye gerek yoktur. Fakat, fonksiyonunuzun daha tutarlı olması ve hata riskini azaltmak için, istenildiği takdirde parametrelerin değişken türleri belirtilebilir.


#+BEGIN_SRC php :results value verbatim
  function yasHesapla(int $dogumtarihi) {
    echo 2021-$dogumtarihi;
  }
  yasHesapla(1980);
  yasHesapla("abc"); // PHP Fatal error:  Uncaught TypeError: Argument 1 passed to yasHesapla() must be of the type int
#+END_SRC

#+RESULTS:

Type hinting yapmak istediğimiz parametrenin önüne, o parametrenin olacağı değişken türünü yazmalıyız : ~int $dogumtarihi~

*** Fonksiyondan Birden Fazla Değer Döndürme
Dizi türünüden bir değer döndürerek bir fonksiyondan birden fazla değerin dönmesi sağlanabilir.

#+BEGIN_SRC php :exports both
  function yasveSansliSayi($dogumyili)
  {
      $yas = 2021-$dogumyili;
      $sansli_sayi = $yas%10 + 2;
      return array($yas, $sansli_sayi);
  }
  $veri = yasveSansliSayi(1985);
  echo "Yaşınız {$veri[0]}, şanslı sayınız {$veri[1]}";  
#+END_SRC

#+RESULTS:
: Yaşınız 36, şanslı sayınız 8

#+BEGIN_alistirma
Kişinin doğduğu ayı parametre olarak alan ve kişinin sahip olabileceği burçları dizi olarak döndüren bir program yapınız.
Örnek: ~burcHesapla(7) => array("Yengeç", "Aslan")~
#+END_alistirma

*** Fonksiyonun Dönüş Değerini Bildirme
Fonksiyonun hangi türden değer döndüreceği bildirilebilir.

#+BEGIN_SRC php exports: both
  function yasHesapla($dogumtarihi) : int {
    return 2021-$dogumtarihi;
  }
  echo yasHesapla(1980);
#+END_SRC

#+RESULTS:
: 41

Dönüş değerinin türünün bildirilmesi durumunda, bu türden bağımsız olarak fonksiyon ~NULL~ değer de döndürebilir.

#+BEGIN_SRC php exports: both
  function yasHesapla($dogumtarihi) {
    $yas = 2021-$dogumtarihi;
  }
  $deger = yasHesapla(2022);
echo $deger;
#+END_SRC

#+RESULTS:


#+BEGIN_SRC php exports: both
  $names = array("Fred", "Barney", "Wilma", "Betty");
  function &birinciyiBul($n) {
      global $names;
      return $names[$n];
  }
  $person =& birinciyiBul(1); // Barney
  $person = "Barnetta"; // changes $names[1]
  var_dump($names);
#+END_SRC

#+RESULTS:
#+begin_example
array(4) {
  [0]=>
  string(4) "Fred"
  [1]=>
  &string(8) "Barnetta"
  [2]=>
  string(5) "Wilma"
  [3]=>
  string(5) "Betty"
}
#+end_example

*** İsimsiz Fonksiyonlar
Bazı PHP fonksiyonlarının görevlerini icra edebilmesi için parametre olarak değişkenden daha fazlasına ihtiyaç duyarlar. Böyle fonksiyonlar, bu durumun üstrsinden gelmek için başka bir fonksiyonu parametre olarak kullanabilirler. Örneğin, ~usort(array &$array, callable $callback) : bool~ fonksiyonu bir dizinin elemanlarını sıralar. İkinci parametresi ~$callback~ ~callable~ türündendir. ~callable~ türü bu değişkenin bir fonksiyon olması gerektiğini ifade eder. Açıktır ki bu fonksiyon, dizinin elemanlarının nasıl sıralacağını belirleyen fonksiyondur.

Parametre olarak kullanılacak fonksiyon, normal bir fonksiyon gibi tanımlanabilir.

#+begin_src php
  $sayilar = [1,3,5,7];
  function islemuygula($dizi, $islem) {
      foreach($dizi as $sayi) {
          echo $islem($sayi) . "\n"; // $islem bir parametre alan bir fonksiyon olmalı.
      }
  }

  function kareal($sayi) {
      return $sayi*$sayi;
  }

  function kupal($sayi) {
      return $sayi*$sayi*$sayi;
  }


  islemuygula($sayilar, kareal);
  islemuygula($sayilar, kupal);
#+end_src

#+RESULTS:
: 1
: 9
: 25
: 49
: 1
: 27
: 125
: 343



Yada isimsiz fonksiyonlar bir değişkene atanır ve bu değişken bir fonksiyona parametre olarak verilebilir. 
#+begin_src php
  $sayilar = [1,3,5,7];
  function islemuygula($dizi, $islem) {
      foreach($dizi as $sayi) {
          echo $islem($sayi) . "\n";
      }
  }

  $kareal = function($sayi) {
      return $sayi*$sayi;
  }; // Bu durumda ; gerekli

  $kupal = function($sayi) {
      return $sayi*$sayi*$sayi;
  };

  islemuygula($sayilar, $kareal);
  islemuygula($sayilar, $kupal)
#+end_src

#+RESULTS:
: 1
: 9
: 25
: 49
: 1
: 27
: 125
: 343


Fakat isimsiz fonksiyonlar genellikle geçici olarak gerekli olan ve hemen tüketilen fonksiyonlar olduğundan dolayı, direkt ilgili fonksiyona isimsiz olarak parametre olarak da geçilebilir.
#+begin_src php
  $sayilar = [1,3,5,7];
  function islemuygula($dizi, $islem) {
      foreach($dizi as $sayi) {
          echo $islem($sayi) . "\n";
      }
  }

  islemuygula($sayilar, function($sy) {return sqrt($sy);});
  islemuygula($sayilar, function($sy) {
      return sqrt($sy);
  });

#+end_src

       #+RESULTS:
       : 1
       : 1.7320508075689
       : 2.2360679774998
       : 2.6457513110646
       : 1
       : 1.7320508075689
       : 2.2360679774998
       : 2.6457513110646


#+begin_src php
      $array = array("abdulmuttalip", "ramazan", "ali", "levent");
      $siralamaKriteri = 'random';

      usort($array, function($a, $b) use ($siralamaKriteri)
      {
          if ($siralamaKriteri == 'random') {
              return rand(0, 2) - 1;
          }
          else {
              return strlen($a) - strlen($b);
          }
      });
      print_r($array);
      echo $sortOption;

#+end_src

#+RESULTS:
: Array
: (
:     [0] => abdulmuttalip
:     [1] => levent
:     [2] => ramazan
:     [3] => ali
: )


#+begin_src php
  $array = array("abdulmuttalip", "ali", "ramazan", "mehmet");
  $siralamaKriteri = "random";

  function sirala($array)
  {
      //$sortOption = false;
      usort($array, function($a, $b) use ($siralamaKriteri)
      {
          if ($siralamaKriteri == "random") {
              // sort randomly by returning (-1, 0, 1) at random
              return rand(0, 2) - 1;
          }
          else {
              return strlen($a) - strlen($b);
          }
      });
      print_r($array);
  }
  print_r(sirala($array));
#+end_src

#+RESULTS:
: Array
: (
:     [0] => abdulmuttalip
:     [1] => mehmet
:     [2] => ramazan
:     [3] => ali
: )

#+begin_src php
    $deneme = "abc";
  function fonk() {
    //global $deneme;
    echo $deneme;
  }
fonk();
#+end_src

#+RESULTS:

** Diziler
** Metin İşlemleri
*** str_replace Fonksiyonu
Bir metin içerisinde başka bir metin varsa onu belirtilen metin ile değiştirir.
=str_replace($degismesiIstenenMetin, $degisecegiMetin, $degismeninYapilacagiMetin)=

#+begin_src php
  $karsila="Merhaba Ahmet, hoşgeldin. Yaşın kaç Ahmet";
  echo str_replace("Ahmet", "Ali", $karsila);
#+end_src

#+RESULTS:
: Merhaba Ali, hoşgeldin. Yaşın kaç Ali

#+begin_src php
  $beslen  = "Her gün pizza, dondurma ve kola tüketmelisin.";
  $sagliksiz = array("pizza", "kola", "dondurma");
  $saglikli  = array("meyve", "lifli gıda", "sebze");
  
  $beslendi = str_replace($sagliksiz, $saglikli, $beslen);
  echo $beslendi;
#+end_src

#+RESULTS:
: Her gün meyve, sebze ve lifli gıda tüketmelisin.

*** explode Fonksiyonu
Bir metni başka bir metne göre parçalar ve dizi oluşturur.
=explode($ayrac, $parcalanacak_metin, $limit)=

#+begin_src php
  $beslen  = "Her gün pizza, dondurma ve kona tüketmelisin.";
  // Boşluklara göre diziye çevirelim.
  var_dump(explode(" ", $beslen));
  
  // on metnine göre parçala
    var_dump(explode("on", $beslen));
  #+end_src

  #+RESULTS:
  #+begin_example
  array(7) {
    [0]=>
    string(3) "Her"
    [1]=>
    string(4) "gün"
    [2]=>
    string(6) "pizza,"
    [3]=>
    string(8) "dondurma"
    [4]=>
    string(2) "ve"
    [5]=>
    string(4) "kona"
    [6]=>
    string(14) "tüketmelisin."
  }
  array(3) {
    [0]=>
    string(17) "Her gün pizza, d"
    [1]=>
    string(10) "durma ve k"
    [2]=>
    string(16) "a tüketmelisin."
  }
  #+end_example

*** implode Fonksiyonu
Diziyi metine çevirmeye yarar.

=implode($ayrac, $birlestirilecek_dizi)=

#+begin_src php
  $kelimeler  = array("Her","gün", "pizza", "dondurma", "ve", "kola", "tüketmelisin");
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  var_dump(implode("", $kelimeler));
  #+end_src

  #+RESULTS:
  : string(39) "Hergünpizzadondurmavekolatüketmelisin"

  #+begin_src php
  $kelimeler  = array("Her","gün", "pizza", "dondurma", "ve", "kola", "tüketmelisin");
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  var_dump(implode(" ", $kelimeler));
  #+end_src

  #+RESULTS:
  : string(45) "Her gün pizza dondurma ve kola tüketmelisin"

  #+begin_src php
  $kelimeler  = array("Her","gün", "pizza", "dondurma", "ve", "kola", "tüketmelisin");
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  var_dump(implode(" xyz ", $kelimeler));
  #+end_src

  #+RESULTS:
  : string(69) "Her xyz gün xyz pizza xyz dondurma xyz ve xyz kola xyz tüketmelisin"


*** strpos Fonksiyonu
Bir metni, bir başka metin içerisinde arar ve varsa ilk bulduğu yerin kararter sırasını döndürür yoksa =false= döndürür.
=strpos($arama_yapilacak_metin, $aranacak_metin)=
#+begin_src php
  $deneme = "ofisdokumalari.pdf";
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  var_dump(strpos($deneme, "."));
  #+end_src

  #+RESULTS:
  : int(14)

#+begin_src php
  $deneme = "Ahmet, bugün gelirken bana meyve, sebze ve yoğurt al";
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  var_dump(strpos($deneme, ","));
  #+end_src

  #+RESULTS:
  : int(5)

  #+begin_src php
  $deneme = "ofisdokumalari.pdf";
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  var_dump(strpos($deneme, ","));
  #+end_src

  #+RESULTS:
  : bool(false)

*** substr Fonksiyonu
Bir metnin belli bir bir parçasını döndürür.
=substr($parcasi_istenen_metin, $parcanin_basinin_karakter_sirasi, $parca_uzunlugu)=

#+begin_src php
  $deneme = "Dereotu";
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  // D e r e o t u
  // | | | | | | |
  // 0 1 2 3 4 5 6
  //         o t 
  //         | |
  //         1 2
  var_dump(substr($deneme, 4, 2));
  #+end_src

  #+RESULTS:
  : string(2) "ot"

#+begin_src php
  $deneme = "Dereotu";
  // Dizi elemanları ayraç olmadan birleştiriliyor.
  // D e r e o t u
  // | | | | | | |
  // 0 1 2 3 4 5 6
  //         o t 
  //         | |
  //         1 2
  var_dump(substr($deneme, 4));
  #+end_src

  #+RESULTS:
  : string(3) "otu"
  

** PHP'de Sınıf ve Nesne Kavramları
*** Sınıf
Gerçek yaşamda problem düşünüldüğünde, kendine ait özellikleri ve davranışları olan ve bu açıdan bir bütün teşkil eden birimlerin programa aktrılmış hallerine *sınıf* denir. Programınızda sınıf olacak yapılar probleminizin özneleridir. Sınıfların özellik ve davranışları tamamiyle probleminize göre şekillenir. Örneğin, bir aracın vergi tutarını hesaplamak istediğinizde, açıktır ki sınıf olarak kullanacağınız yapı araç olacaktır. Benzer şekilde bir araç kiralama uygulaması geliştiriyorsanız yani programnızda kullanacağınız sınıflardan biris araç olacaktır. Her ne kadar iki problemde de aynı sınıfı kullanıyor olsanız da problemlerin farklılığından dolayı bu iki programda kullanılan araç sınıfın özellik ve davranışları biribirinden farklı olacaktır.
Örneğin, aracın vergi hesabında sadece aracın  yaşı ve motor hacmi ile ilgilenmeniz gerekirken, araç kiralama uygulamasında aracın modeli, koltuk sayısı gibi başka özellikle de ilgilenmeniz gerekir. Probleminizin kapsamına göre bu özellikleri kendinizin belirliyor olmasın çok büyük bir kolaylıktır. Bu açıdan düşünüldüğünde sınıf, problemizde sınıf olarak kullanacağınız yapıların bir tanımıdır.
*** Nesne
Sınıflar ile problemimizin uğraştığı yapıları tanımladıktan sonra, bu tanımları ihlal etmemek koşulu ile onların somut bir örneğini oluşturabiliriz. Sınıflar soyut kavramlar olarak düşünülürse, nesneler bu soyut kavramları somut halleridir. Örneğin ~arac~ bir sınıf ise ~hondacivic~ araç sınıfının bir nesnesi olarak düşünülebilir.
*** Nesne Tabanlı Programlamanın Özellikleri
**** Abstraction(Soyutlama)
Sınıf tasarımının nesnenin sadece gerekli olan temel özellikleri ile yapılması anlamına gelir. Örneğin, ~Iletisim~  isimli bir sınıfımız olsun. ~Iletisim~ sınıfının temel davranışı ~MesajGonder~ olsun. ~MesajGonder~ eylemi farklı biçimlerde gerçekleşebileceği için burada bir soyutlama yapılmış olur. ~Iletisim~ sınıfında türetilen farklı nesneler ~MesajGonder~ davranışını farklı biçimlerde ifa edebilirler. Fakat soyut olarak düşünüldüğünde gerçekleştirilen temel eylem aynıdır, yani ~MesajGonder~. Örneğin, SMS ile bir meaj gönderilebilir ya da e-posta ile de mesaj gönderilebilir.
**** Encapsulation(Kapsülleme)
Nesnenin, kendine ait verileri ve davranışları bir birim olarak kendi bünyesi içine alabilmesidir. Bu özelliklerdeki ve davranışlardaki değişimler birim olarak direkt nesnenin içinde gerçekleştiğinden; nesne istediği özellik ve davranışlara kendi birimi dışında bir noktadan erişilmesini kısıtlayabilir. Birimin özellik ve davranışları kendi dış dünyasından gizleyebilme yeteneği güvenlik açısından önemli role sahiptir.
Örneğin, ~Vergi~ ismimli bir sınıfımız ve bu sınıfın ~Hesapla()~ isimli bir davranışı ve ~vergiOrani~ isimli bir özelliği olsun. Başka nesnelerin bir ~Vergi~ nesnesinin ~Hesapla()~ metodunu kullanmasına müsaade edecek, fakat ~vegiOranı~ özelliğini değiştirmesini iatemeyexeğiz. Çünkü 2020 yılında 1.5 olarak belirlenen ~vergiOrani~, başka bir nesneni onu 0.9 ile değiştirmesi sonucu, ~Hesapla()~ fonksiyonunun hatalı değer üretmesine neden olacaktır.

** Veritabanları
Dinamik web siteleri oluşturmak için kullanıcılardan gelen bilgileri Veritabanlarında tutmamız gerekir
PHP bir çok veritabanı sistemini destekler. PHP veritabanı işlemleri için PDO(PHP Data Objects) kütüphanesini kullanır.
*** Veritabanı İşlemleri İçin PHP Kullanılması
PHP'de veritabanı işlemlerini yerine getirmek için iki yol vardır. Birincisi, kullandığınız veritabanına özel dil eklentisini kullanmak. Diğeri ise herhangi bir veritabanı ile kullanabileceğiniz PDO.
İki yönteminde kendine göre avantajları ve dezavantajları vardır. Veritabanı özel eklenti kullandığınzıda, yazdığınız kod tümüyle o veritabanı türüne özel olacaktır. Veritabanınızı değiştirmek istediğinizde kodunuz çalışmayacak ve kodunuzun eski veritabanı ile ilgili tüm kısımlarını değiştirmeniz gerekecek.
PDO ile yazılan kodlar veritabanın türünden bağımsız olur ve veritabanınızı türünü değiştirmeniz durumunda bile düzgün çalışmaya devam eder. Tabii PDO bir çok farklı veritabanı türünüww uyum sağlayacak şekilde tasarlanmış olduğundan eklenti yöntemine göre biraz hantal kalır.
*** PDO Kullanımı
PDO, veritabanı işlemleri için kullanılan bir PHP eklentisidir. Bir çok veritabanı türünü destekler. Programınızda PDO kullanabilmek için, PHP konfigürasyonunuzda PDO eklentisini ve PDO kullanacağınız veritabanı türüne ait eklentisini aktif hale getirmek gerekir. Örneğin PDO mysql veritabanı için kullanılacaksa php.ini dosyası

#+begin_src bash
extension=php_pdo.dll
extension=php_pdo_mysql.dll
#+end_src

satırlarını içermelidir.
**** Veritabanına Sunucusuna Bağlanma
Bir veritabanı üzerinde işlemler yapabilmek için o veritabanının bulunduğu veritabanı sunucusuna bağlanmak gerekir. Bu bağlantıyı sağlayabilmek için,
- Veritabanı sunucusunun adresi ve portu
- Veritabanı sunucusuna ait bir kullanıcı ismi ve bu kullanıcının şifresi.
- İşlem yapacağınız veritabanın ismi.
  bilgilerine ihtiyaç vardır.

  PDO ile veritabanına bağlanmak için, 
  #+begin_src php
$db = new PDO($dsn, $username, $password);
  #+end_src

  kodu kullanılır. Burada ~$dsn~ /data source name/ anlamındadır ve veritabanı sunucusu ve veritabanınız hakkında bilgilerden oluşur.
  Örneğin bir mysql veritabanına bağlancaksınız kodunuz, 

 #+begin_src php
$db = new PDO("mysql:host=localhost;dbname=library", $username, $password);
#+end_src

  biçimine benzer olacaktır.
**** Bağlantı Hatalarını Yakalamak
Veritabanına bağlantı kurma eylemi, bizim kontrolümüzde olmaya bir çok sorunla karşılaşabilir. Örneğin veritabanı sunucusunun çalışmıyor olması, yada bağlantı sorunları gibi. Bu durumda oluşacak sorunları önceden tespit edebilmek adına ~try-catch~ yapısının kullanırız. ~try-catch~ yapısı, hata benzeri istisna adı verilen durumları yakalar ve bunların tipine göre işlem yapmamızı sağlar.

#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }
  echo "\nDevam ediyor mu?"
#+end_src

  #+RESULTS:
  : SQLSTATE[HY000] [2002] No such file or directory
  : Devam ediyor mu?

~try-catch~ yapısında bir istisna ile karşılaşıldığında, istisnanın olduğu satırdan sonraki satırlar çalıştırılmaz. Program akışı ~catch~ bloğundan devam eder.
#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler1", "okten", "QBsfA6Sg73gnfRFg");
      echo "Devam";
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  } catch (Throwable $e) {
      echo $e->getMessage();
  }
  echo "\nDevam ediyor mu?"
#+end_src

#+RESULTS:
: SQLSTATE[HY000] [1049] Unknown database 'ogrenciler1'
: Devam ediyor mu?

#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten1", "QBsfA6Sg73gnfRFg");
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }
#+end_src

#+RESULTS:
: SQLSTATE[HY000] [1045] Access denied for user 'okten1'@'localhost' (using password: YES)

**** Veritabanı Üzerinde İşlem Yapma
Veritabanı üzerinde en çok yapılan işlemler: listeleme, düzenleme, ekleme ve silmedir.
Veritabanı sorgularını aşağıdaki şekilde gruplandırmak mümkündür:

1. Veri Döndürmeyen Sorgular
   INSERT, UPDATE ve DELETE gibi SQL sorgularının veritabanı tablosundan veri döndürmesi beklenmez. Bunun yerine, sorgunun başarılı olup olmadığıyla igililenilir. Sorgunun başarılı olup olmadığı ise, sorgu sonucu tabloda değişen kayıt sayısı kontrol edilerek tespit edilir. Bu durumda ~PDO~ sınıfının ~exec()~ fonksiyonu kullanılabilir. ~exec~ fonksiyonu yalnızca veritabanı sorgusundan etkilenen kayıtların sayısını döndürür.
2. Veri Döndürmesi Beklenen Sorgular
   SELECT sorgusu veritabanı tablosundan kayıtları seçer. Veritabanı tablosundan kayıt veya kayıtlar döndürmesi beklenen sorgular için ~query()~ fonksiyonu kullanılır.

Örneklerde kullanacağımız veritabanının yapısı:

#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum    | dogumyili |
|--------+-------+-------+----------+-----------|
|    125 | Ali   | VELİ  | İnşaat   |      2000 |
|    126 | Fatma | MERT  | Otomotiv |      2000 |
|    127 | Ayşe  | MERT  | Otomotiv |      2000 |



***** Veritabanı Tablosuna Veri Ekleme
~new_table~ isimli bir veritabanına kayıt eklemek için aşağıdaki şekilde bir kod kullanılabilir.
#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "INSERT INTO new_table (numara, ad, soyad, bolum, dogumyili) VALUES(128, 'Zehra', 'FIRAT', 'Harita', 2001)";
      $etkilenen = $db->exec($sorgu);
      echo "İşlemden etkilenen kayıt satırı sayısı : $etkilenen";
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }

#+end_src

#+RESULTS:
: İşlemden etkilenen kayıt satırı sayısı : 1

Yukarıdaki örnekte,  ~new_table~ tablosuna bir kayıt eklendi. ~exec~ fonksiyonu, parametre olarak aldığı SQL sorgusundan etkilenen kayıt sayısını döndürür. Yukarıdaki program, tabloya bir kayıt ekler.  ~new_table~ tablosunun, ~exec~ ile bir sorgu çalıştırılmadan önceki durumu ile çalıştırıldıktan sonraki durumu arasında sadece eklenen satır farkı olduğu için, 1 değerini  döndürdü. 

Tablonun son hali aşağıdaki gibidir. 
#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum    | dogumyili |
|--------+-------+-------+----------+-----------|
|    125 | Ali   | VELİ  | İnşaat   |      2000 |
|    126 | Fatma | MERT  | Otomotiv |      2000 |
|    127 | Ayşe  | MERT  | Otomotiv |      2000 |
|    128 | Zehra | FIRAT | Harita   |      2001 |

***** Veritabanı Tablosundaki Kayıtları Güncelleme
~new_table~ isimli bir veritabanındaki kayıtları güncellemek için aşağıdaki şekilde bir kod kullanılabilir.
Bu kod numarası 127 olan öğrencinin veya öğrencilerin bölümünü Elektronik olarak değiştirmektedir. Kullandığımız tabloda, numarası 127 olan tek bir kayıt olduğundan dolayı, bu işlemden etkilenen kayıt sayısı 1 olacaktır.

#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "UPDATE new_table SET bolum='Tekstil' WHERE numara=126"; 
      $etkilenen = $db->exec($sorgu);
      echo "İşlemden etkilenen kayıt satırı sayısı : $etkilenen";
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }

#+end_src

#+RESULTS:
: İşlemden etkilenen kayıt satırı sayısı : 0

Tablonun son hali aşağıdaki gibidir. 
#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum    | dogumyili |
|--------+-------+-------+----------+-----------|
|    125 | Ali   | VELİ  | İnşaat   |      2000 |
|    126 | Fatma | MERT  | Tekstil  |      2000 |
|    127 | Ayşe  | MERT  | Otomotiv |      2000 |
|    128 | Zehra | FIRAT | Harita   |      2001 |



UPDATE işleminden etkilenen kayıtlar birden fazla olabilir. Örneğin; tablomuzda, doğum yılı 2000 olan öğrencilerin bölümünü İnşaat olarak değiştirmek istersek, bu işlemden dört kayıt etkilenecektir.

#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "UPDATE new_table SET bolum='İnşaat' WHERE dogumyili=2000"; 
      $etkilenen = $db->exec($sorgu);
      echo "İşlemden etkilenen kayıt satırı sayısı : $etkilenen";
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }

#+end_src

#+RESULTS:
: İşlemden etkilenen kayıt satırı sayısı : 2



Tablonun son hali aşağıdaki gibidir. 
#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum  | dogumyili |
|--------+-------+-------+--------+-----------|
|    125 | Ali   | VELİ  | İnşaat |      2000 |
|    126 | Fatma | MERT  | İnşaat |      2000 |
|    127 | Ayşe  | MERT  | İnşaat |      2000 |
|    128 | Zehra | FIRAT | Harita |      2001 |


***** Veritabanından Kayıt Silme
Veritababınından kayıt silmek için DELETE sql deyimi kullanılır.
#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "DELETE FROM new_table WHERE bolum='Harita'"; 
      $etkilenen = $db->exec($sorgu);
      echo "İşlemden etkilenen kayıt satırı sayısı : $etkilenen";
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }
#+end_src

#+RESULTS:
: İşlemden etkilenen kayıt satırı sayısı : 1

Tablonun son hali aşağıdaki gibidir. 
#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum  | dogumyili |
|--------+-------+-------+--------+-----------|
|    125 | Ali   | VELİ  | İnşaat |      2000 |
|    126 | Fatma | MERT  | İnşaat |      2000 |
|    127 | Ayşe  | MERT  | İnşaat |      2000 |

***** Veritabanındaki Kayıtları Listeleme
Veritabanındaki kayıtları temel olarak listelemek için PDO nesnesinin ~query~ metodu SELECT sql deyimi ile birlikte kullanılır.
#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "SELECT * FROM new_table"; 
      foreach($db->query($sorgu) as $kayit) {
          // $kayit tabloda bir satıra karşılık gelir.
          // Bu yüzden $kayit, tablodaki alanların isimleri anahtarları olcak şekilde
          // değerleri taşır. 
          echo $kayit['numara'];
          echo "\n";
      }

  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }

#+end_src

#+RESULTS:
: 125
: 126
: 127


SELECT sql sorgusu sonucu kaç kayıt döneceğini öğrenmek için ~rowCount~ metodu kullanılır.
#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "SELECT * FROM new_table WHERE soyad='MERT'";
      $kayitSayisi = $db->query($sorgu)->rowCount();
      echo "Toplam $kayitSayisi adet kayıt listelenecektir.";
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }

#+end_src

#+RESULTS:
: Toplam 2 adet kayıt listelenecektir.


**** Veritabanı Üzerinde İşlemleri Güvenli Yapma
SQL sorgularını çoğunlukla ziyaretçiden alınan verilerle oluşturulur. Bu açıdan bakıldığında, ziyaretçi SQL sorgusu vasıtasıyla dolaylı yoldan da olsa programınızda bir kod çalıştırma yetkisi kazanmış olur. Bu sebepten ziyaretçilerin SQL sorgusuna geçirdikleri verileri incelemek önem arz etmektedir. Kötü niyetli kullanıcılar, SQL sorgularında kullanacakları bazı illegal deyimler vasıtıasıyla veritabanınıza müdahale edbilirler. Bu işleme de SQL injection denir.
SQL sorgusu içine yerleştireceğimiz verileri, kötü niyetli amaçlardan temizlemek ve SQL sorgusuna güvenli hale getirmek için ~prepare~ metodu kullanılır. 
***** ~prepare~ Metodunun Kullanımı
~prepare~ metodunun kullanım biçimi ~PDOStatement PDO::prepare(string query [, array driver_options])~ şeklindedir. Burada, çoğunlukla ~prepare~ içerisine sadece sorgu yazılır. Fakat sorguyu yazarken, sorguda değişken olan bölümler yani sorguya dışarıdan aktarılacak olan veriler direkt yada değişken formunda değil yer tutucu formunda yazılırlar. Bu işlemde iki biçimde yapılabilir.
- İsimli Paremetreler
  Her bir yer tutucu ~:isim~ formatında olmalıdır. Yani bir ~:~ karakteri ve onu takip eden bizim seçtiğimiz bir isim.
  Örnek: ~UPDATE new_table SET numara=:num WHERE bolum=:bol~
Burada yer tutucular: ~:num~ ve ~:bol~ bölümleridir. 
- Soru İşareti Parametreleri
  Örnek: ~UPDATE new_table SET numara=? WHERE bolum=?~

  ~prepare~ ile hazırlanmış bir sorguyu çalıştırmak için ~PDO~ sınıfına ait ~execute~ fonksiyonu kullanılır. ~execute~ fonksiyonu, ~public PDOStatement::execute ( array $input_parameters = null ) : bool~ şeklinde tanımlanmıştır. Yani dizi türünden bir parametre kabul eder. Bu dizi türünden parametre, ~prepare~ fonksiyonundaki yer tutucular ve bu yer tutuculara aktarılacak değerler şeklindedir.
  Örneğin,   ~$deyim = $db->prepare("UPDATE new_table SET numara=:num WHERE bolum=:bol")~ şeklinde ise, ~execute~ fonksiyonu, ~$deyim->execute([':num' => 145, ':bol' => 'Kimya'])~ şeklinde olacaktır. 
  


#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "UPDATE new_table SET bolum=:blm WHERE soyad=:sad";
      $sqlDeyimi = $db->prepare($sorgu);
      $durum = $sqlDeyimi->execute([':blm'=>'Tekstil', ':sad'=>'MERT']);
      echo "Durum : $durum";

  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }

#+end_src

#+RESULTS:
: Durum : 1
  


Tablonun son hali aşağıdaki gibidir. 
#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum   | dogumyili |
|--------+-------+-------+---------+-----------|
|    125 | Ali   | VELİ  | İnşaat  |      2000 |
|    126 | Fatma | MERT  | Tekstil |      2000 |
|    127 | Ayşe  | MERT  | Tekstil |      2000 |



#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "UPDATE new_table SET bolum=? WHERE soyad=?";
      $sqlDeyimi = $db->prepare($sorgu);
      $durum = $sqlDeyimi->execute(['Otomotiv', 'MERT']);
      echo "Durum : $durum";

  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }

#+end_src

#+RESULTS:
: Durum : 1

Tablonun son hali aşağıdaki gibidir. 
#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum    | dogumyili |
|--------+-------+-------+----------+-----------|
|    125 | Ali   | VELİ  | İnşaat   |      2000 |
|    126 | Fatma | MERT  | Otomotiv |      2000 |
|    127 | Ayşe  | MERT  | Otomotiv |      2000 |

****** Parametre Bağlama
Yukarıdaki kullanıma ek olarak, ~prepare~ fonksiyonuna aktarılacak değerler için ~bindParam~ fonksiyonu da kullanılabilir.
~bindParam~ fonksiyonu =boolean PDOStatement::bindParam(mixed parameter, mixed &variable [, int
datatype [, int length [, mixed driver_options]]])= biçiminde tanımlanmıştır.
Burada =parameter=, ~prepare~ fonksiyonu için oluşturuduğumuz SQL sorgularında bulunan isimli yer tutuculardır. Örneğin ~:num~ gibi.
~variable~ ise, bu yer tutucunun yerine aktaracağınız değeridir.
~datatype~, yer tutucunun kabul edeceği değerlerin hangi türden olacağını bildirir.
- ~PDO::PARAM_BOOL~ : Boolean türü
- ~PDO::PARAM_INT~ : SQL tamsayı türü
- ~PDO::PARAM_STR~ : SQL metin türü


#+begin_src php
  try {
      $db = new PDO("mysql:host=localhost;dbname=ogrenciler", "okten", "QBsfA6Sg73gnfRFg");
      $sorgu = "INSERT INTO new_table (numara, ad, soyad, bolum, dogumyili) VALUES(:num, :ad, :sad, :blm, :dyil)";
      $sqlDeyimi = $db->prepare($sorgu);
      $numara = 145;
      $ad = 'Akif';
      $soyad = 'BAŞ';
      $bolum = 'Harita';
      $dogumyili = 2003;
      $sqlDeyimi->bindParam(':num', $numara);
      $sqlDeyimi->bindParam(':ad', $ad);
      $sqlDeyimi->bindParam(':sad', $soyad);
      $sqlDeyimi->bindParam(':blm', $bolum);
      $sqlDeyimi->bindParam(':dyil', $dogumyili);
      $sqlDeyimi->execute();
  }
  catch (PDOException $e) {
      echo $e->getMessage();
  }
  catch (Throwable $e) {
      echo $e->getMessage();
  }
#+end_src

#+RESULTS:



Tablonun son hali aşağıdaki gibidir. 
#+header: :engine mysql
#+header: :dbhost localhost
#+header: :dbuser okten
#+header: :dbpassword QBsfA6Sg73gnfRFg
#+header: :database ogrenciler
#+begin_src sql :exports results
  select * from new_table;
#+end_src

#+RESULTS:
| numara | ad    | soyad | bolum    | dogumyili |
|--------+-------+-------+----------+-----------|
|    125 | Ali   | VELİ  | İnşaat   |      2000 |
|    126 | Fatma | MERT  | Otomotiv |      2000 |
|    127 | Ayşe  | MERT  | Otomotiv |      2000 |
|    145 | Akif  | BAŞ   | Harita   |      2003 |
** Kullanıcı Oturumları
*** Oturumlar(Sessions)
Masaüstünde çalışan bir sınav uygulaması düşünelim. Program her seferinde karşımıza tek bir soru çıkartacak ve o soruyu cevaplayınca diğer soruya geçecek şekilde tasarlanmış olsun. Bu durumda üçüncü soruya geçtiğimizde birinci soruya verdiğimiz cevap program için bellekte ayrılan alanda saklanmaktadır. Yani her soru ekranını programın ayrı bir durumu olarak düşünürsek, program bütün durumları belleğinde tutabilmektedir.
Benzer bir uygulamayı web üzerinde yaparsak, her soru geçişinde sayfa yenilenecek ve önceki sayfalardaki bilgiler kaybedilmiş olacaktır. Örneğin üçüncü sorunun sayfasında iken, birinci soruya verilen cevap artık mevcut değildir. Çünkü HTTP'de her sayfa yükleme eylemi bağımsız bir olaydır. Bazı özel mekanizmalar kullanılmadığı sürece, bir ziyaretçinin web sitenizde yaptığı sayfa yüklemeleri arasında veri transferi yapmak mümkün değildir.
Sunucu taraflı uygulamalar, dinamik web sayfaları oluşturabilmek için web sitesini ziyaret eden çok sayıda kullanıcıyı birbirinden ayırt etmek isteyecektir. Özellikle tekil bir kullanıcının web sitesine girdiği andan web sitesini terkettiği ana kadar ziyaretçiyi tanımlayabilmek, ziyaretçinin izini sürmek ve bu izleri aynı kullanıcının sonraki ziyaretlerinde kullanmak ister. Fakat HTTP'de her bir sayfa yükleme eyleminin bağımsız olmasından dolayı bu işlem için farklı yollar izlenir.
HTTP'de yapılan her isteğin önceki isteklerden bağımsız olmasına *HTTP'nin durumsuzluğu* denir.
Bir ziyaretçinin web sitesine girdiği andan web sitesini terkettiği ana kadar geçen süreye o ziyaretçinin *oturumu* denir. 

*** Cookies
Çerez, ziyaret ettiğiniz bir web sitesi tarafından bilgisayarınızda depolanan bilgilerdir. Bazı tarayıcılarda her çerez ayrı ayrı küçük dosyalar halinde tutulurken Firefox'ta tüm çerezler Firefox'un profil klasöründeki tek bir dosyasında tutulur.

Çerezler genellikle ilgili web sitesine ait dil tercihiniz veya konumunuz gibi ayarlarınızı saklamak için kullanılır. Aynı siteye yeniden girdiğinizde Firefox, o siteye ait çerezleri siteye geri gönderir. Böylece site, ihtiyaçlarınıza uyacak şekilde özelleştirilmiş bilgiler sunabilir.

Ayrıca çerezler, kişisel bilgileriniz (adınız, e-posta adresiniz, telefon numaranız vb.) de dahil olmak üzere birçok farklı bilgi içerebilir. Ancak, bir sitenin ulaşabileceği bilgiler sizin ona sunduklarınızla sınırlıdır. Web siteleri onlara vermediğiniz bilgilere erişemez. Ayrıca hiçbir site, bilgisayarınızdaki diğer dosyaları ulaşamaz.

Varsayılan olarak çerezleri saklama ve gönderme işlemleri tamamen görünmez bir şekilde gerçekleşir.
[[cite:&CerezlerWebSitelerinin]]

Bir sitesinin web sunucusu, yollayacağı bir HTTP cevabı vasıtası ile tarayıcıya, istemci bilgisayarda o web sitesi ile ilişkilendirilmiş bir çerez oluşturma talimatı verir. Tarayıcı çerezleri kabul edecek şekilde ayarlara sahipse sunucunun talimatlarına uygun bir çerezi oluşturur. Çerezler genellikle bir veya birden fazla dosya şeklinde diske kaydedilir. Sunucunun çerez oluşturma talimatında aynı zamanda çerezin içeriği de yer alır. Çerezler bir anahtar isimle ilişkilendirilmiş veri tutmak içi kullanılır. Genel formatı,

isim=deger; ozellik1=deger1, ozellik2=deger2

biçimindedir.  Burada /deger/ ihtiyaç duyulan veridir. Bu ihtiyaç duyulan veri HTTP isteklerinde /isim/ adı ile transfer edilir. Özellikler ise çerezin; son kullanım tarihi, etki alanı gibi özellikler ve bunların değerlerinden oluşur.

dil=turkce; Expires=Wed, 24 Nov 2021 07:28:00 GMT, Domain=deneme.com

yukarıdaki biçimde oluşturulmuş bir çerez, ~dil~ anahtarı ile =turkce= verisini taşır. 24 Aralık 2021 saat 07:28'e kadar geçerlidir ve /deneme.com/ domaininden yollanmış ve sadece o domain tarafından okunabilir.



#+BEGIN_SRC php
<html>
  <head>
    <title>PHP Test</title>
  </head>
  <body>
 <table border="1">
<?php
$arka[0] = "white";
$arka[1] = "black";
for($i=1; $i<=8; $i++) {
	
	echo "<tr>";
	for($j=1; $j<=8; $j++) {
		$bg = $arka[($i+$j)%2];
		echo "<td bgcolor='$bg' style='width:50px;height:50px;'></td>";
	}
	echo "</tr>";
}
	
?>
</tr>
</table>
    <script src="https://replit.com/public/js/replit-badge.js" theme="blue" defer></script> 
  </body>
</html>
#+END_SRC

denemek için https://replit.com/@hokten/SatrancTahtasi?v=1#index.php
